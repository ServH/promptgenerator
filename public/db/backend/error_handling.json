{
  "instructions": [
    {
      "id": "back010",
      "title": {
        "es": "Implementar manejo de errores centralizado",
        "en": "Implement centralized error handling"
      },
      "description": {
        "es": "Crear un sistema uniforme para capturar y manejar errores",
        "en": "Create a uniform system for capturing and handling errors"
      },
      "text": {
        "es": "Implementa un sistema centralizado de manejo de errores para asegurar consistencia y facilitar el mantenimiento. Crea un middleware global para capturar errores no manejados, define clases de error personalizadas para diferentes tipos de excepciones, usa códigos de estado HTTP apropiados, mantén mensajes de error consistentes y amigables para el usuario, y asegúrate de registrar los errores adecuadamente para diagnóstico sin exponer información sensible en las respuestas.",
        "en": "Implement a centralized error handling system to ensure consistency and ease maintenance. Create a global middleware to catch unhandled errors, define custom error classes for different exception types, use appropriate HTTP status codes, maintain consistent and user-friendly error messages, and ensure proper error logging for diagnostics without exposing sensitive information in responses."
      },
      "importance": "high",
      "category": "error_handling",
      "subcategory": "architecture",
      "tags": ["backend", "architecture", "robustness"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Error Handling section"
      },
      "compatibility": {
        "frameworks": ["express", "nest", "django", "flask", "spring", "laravel"],
        "languages": ["javascript", "typescript", "python", "java", "php"],
        "environments": ["api", "web", "server"]
      },
      "examples": [
        {
          "context": {
            "es": "Ejemplo de implementación de manejo de errores centralizado en Express",
            "en": "Example of centralized error handling implementation in Express"
          },
          "code": "// Sistema centralizado de manejo de errores en Express (Node.js)\n\n// 1. Definir clases de error personalizadas\nclass AppError extends Error {\n  constructor(message, statusCode, errorCode = null) {\n    super(message);\n    this.statusCode = statusCode;\n    this.errorCode = errorCode || `ERR_${statusCode}`;\n    this.isOperational = true; // Errores operacionales vs. programación\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// Errores concretos para casos específicos\nclass NotFoundError extends AppError {\n  constructor(message = 'Recurso no encontrado') {\n    super(message, 404, 'ERR_NOT_FOUND');\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message = 'Datos de solicitud inválidos', errors = []) {\n    super(message, 400, 'ERR_VALIDATION');\n    this.errors = errors;\n  }\n}\n\nclass UnauthorizedError extends AppError {\n  constructor(message = 'No autorizado') {\n    super(message, 401, 'ERR_UNAUTHORIZED');\n  }\n}\n\nclass ForbiddenError extends AppError {\n  constructor(message = 'Acceso prohibido') {\n    super(message, 403, 'ERR_FORBIDDEN');\n  }\n}\n\nclass ConflictError extends AppError {\n  constructor(message = 'Conflicto con el estado actual') {\n    super(message, 409, 'ERR_CONFLICT');\n  }\n}\n\nclass InternalError extends AppError {\n  constructor(message = 'Error interno del servidor') {\n    super(message, 500, 'ERR_INTERNAL');\n  }\n}\n\n// 2. Middleware para capturar errores específicos (404)\nconst notFoundHandler = (req, res, next) => {\n  next(new NotFoundError(`No se encontró la ruta: ${req.originalUrl}`));\n};\n\n// 3. Middleware para validación de entrada (ejemplo con express-validator)\nconst validate = (validations) => {\n  return async (req, res, next) => {\n    await Promise.all(validations.map(validation => validation.run(req)));\n\n    const errors = validationResult(req);\n    if (errors.isEmpty()) {\n      return next();\n    }\n\n    const extractedErrors = errors.array().map(err => ({\n      field: err.param,\n      message: err.msg\n    }));\n\n    next(new ValidationError('Error de validación', extractedErrors));\n  };\n};\n\n// 4. Middleware manejador de errores centralizado\nconst errorHandler = (err, req, res, next) => {\n  // Establecer valores por defecto para error no operacional\n  let error = err;\n  \n  // Si es un error no controlado, convertirlo a AppError\n  if (!err.isOperational) {\n    // Errores específicos de MongoDB/Mongoose\n    if (err.name === 'CastError') {\n      error = new NotFoundError(`Recurso no válido: ${err.value}`);\n    } else if (err.code === 11000) {\n      const field = Object.keys(err.keyValue)[0];\n      error = new ConflictError(`El ${field} ya existe. Por favor use otro valor.`);\n    } else if (err.name === 'ValidationError') {\n      const errors = Object.values(err.errors).map(val => ({\n        field: val.path,\n        message: val.message\n      }));\n      error = new ValidationError('Datos inválidos proporcionados', errors);\n    } else {\n      // Error desconocido\n      console.error('ERROR NO MANEJADO 💥:', err);\n      error = new InternalError();\n    }\n  }\n\n  // Logging de desarrollo vs producción\n  if (process.env.NODE_ENV === 'development') {\n    console.error('Error Stack:', err.stack);\n  } else {\n    // En producción, loguear en un servicio estructurado como Sentry/Loggly\n    // logger.error({ err, requestId: req.id, user: req.user?.id });\n  }\n\n  // Estructurar respuesta de error\n  const errorResponse = {\n    status: 'error',\n    code: error.errorCode,\n    message: error.message\n  };\n\n  // Incluir detalles adicionales para errores de validación\n  if (error instanceof ValidationError && error.errors) {\n    errorResponse.errors = error.errors;\n  }\n\n  // Incluir stack trace solo en desarrollo\n  if (process.env.NODE_ENV === 'development') {\n    errorResponse.stack = err.stack;\n  }\n\n  // Enviar respuesta\n  res.status(error.statusCode || 500).json(errorResponse);\n};\n\n// 5. Configuración en la aplicación Express\nconst express = require('express');\nconst app = express();\n\n// Middleware y rutas\napp.use(express.json());\n// ... otras configuraciones y rutas\n\n// Estos middleware deben ir AL FINAL de todas las rutas\n// Capturar 404s\napp.use(notFoundHandler);\n\n// Manejador de errores global\napp.use(errorHandler);\n\n// 6. Uso en controladores\nconst getUser = async (req, res, next) => {\n  try {\n    const user = await User.findById(req.params.id);\n    \n    if (!user) {\n      // Usar clases de error personalizadas\n      throw new NotFoundError('Usuario no encontrado');\n    }\n    \n    res.status(200).json({\n      status: 'success',\n      data: { user }\n    });\n  } catch (error) {\n    // Pasar el error al middleware centralizado\n    next(error);\n  }\n};\n\n// 7. Error handling para promesas no gestionadas y excepciones\nprocess.on('unhandledRejection', (err) => {\n  console.error('UNHANDLED REJECTION! 💥 Shutting down...');\n  console.error(err.name, err.message, err.stack);\n  // En producción, considerar el cierre ordenado de la aplicación\n  // server.close(() => {\n  //   process.exit(1);\n  // });\n});\n\nprocess.on('uncaughtException', (err) => {\n  console.error('UNCAUGHT EXCEPTION! 💥 Shutting down...');\n  console.error(err.name, err.message, err.stack);\n  // Para excepciones no capturadas, generalmente es mejor cerrar el proceso\n  process.exit(1);\n});"
        }
      ],
      "relatedInstructions": ["back011", "sec002"]
    },
    {
      "id": "back011",
      "title": {
        "es": "Implementar logging adecuado",
        "en": "Implement proper logging"
      },
      "description": {
        "es": "Establecer un sistema de registro consistente y útil",
        "en": "Establish a consistent and useful logging system"
      },
      "text": {
        "es": "Implementa un sistema de logging robusto y completo para facilitar el seguimiento, depuración y monitoreo de tu aplicación. Utiliza niveles de log apropiados (error, warn, info, debug), estructura los logs en un formato consistente y legible, incluye información contextual como IDs de solicitud y usuarios, configura rotación de archivos de log para entornos de producción, y asegúrate de no registrar información sensible. Considera usar una biblioteca de logging estructurado que facilite filtrado y análisis.",
        "en": "Implement a robust and comprehensive logging system to facilitate tracking, debugging, and monitoring of your application. Use appropriate log levels (error, warn, info, debug), structure logs in a consistent and readable format, include contextual information like request IDs and users, configure log file rotation for production environments, and ensure you don't log sensitive information. Consider using a structured logging library that facilitates filtering and analysis."
      },
      "importance": "medium",
      "category": "error_handling",
      "subcategory": "logging",
      "tags": ["backend", "operations", "monitoring"],
      "source": {
        "agentType": "v0",
        "repository": "v0 Prompts and Tools/Prompt.txt",
        "context": "Backend Best Practices section"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Ejemplo de configuración de logging con Winston en Node.js",
            "en": "Example of logging configuration with Winston in Node.js"
          },
          "code": "// Configuración de logging con Winston en Node.js\nconst winston = require('winston');\nconst { createLogger, format, transports } = winston;\nconst { combine, timestamp, printf, colorize, json } = format;\n\n// Middleware para generar ID único para cada solicitud\nconst { v4: uuidv4 } = require('uuid');\nconst requestId = require('express-request-id')();\n\n// Formateador personalizado para desarrollo (legible por humanos)\nconst devLogFormat = printf(({ level, message, timestamp, ...metadata }) => {\n  let metaStr = '';\n  \n  if (metadata.requestId) {\n    metaStr += `[${metadata.requestId}] `;\n  }\n  \n  if (metadata.userId) {\n    metaStr += `[User: ${metadata.userId}] `;\n  }\n  \n  if (metadata.path) {\n    metaStr += `[${metadata.method} ${metadata.path}] `;\n  }\n  \n  // Añadir otros metadatos como objeto JSON si existen\n  const otherMeta = { ...metadata };\n  delete otherMeta.requestId;\n  delete otherMeta.userId;\n  delete otherMeta.path;\n  delete otherMeta.method;\n  \n  if (Object.keys(otherMeta).length > 0) {\n    metaStr += JSON.stringify(otherMeta);\n  }\n  \n  return `${timestamp} ${level}: ${message} ${metaStr}`;\n});\n\n// Crear logger con configuración diferente según entorno\nconst logger = createLogger({\n  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',\n  defaultMeta: { service: 'api-service' },\n  transports: [\n    // Siempre registrar a la consola\n    new transports.Console({\n      format: combine(\n        colorize(),\n        timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),\n        process.env.NODE_ENV === 'production'\n          ? json() // JSON en producción para parsear fácilmente\n          : devLogFormat // Formato legible en desarrollo\n      )\n    })\n  ]\n});\n\n// En producción, añadir transporte de archivo con rotación\nif (process.env.NODE_ENV === 'production') {\n  // Require solo en producción para no añadir dependencias innecesarias en desarrollo\n  const { DailyRotateFile } = require('winston-daily-rotate-file');\n  \n  // Archivo para todos los logs\n  logger.add(new DailyRotateFile({\n    filename: 'logs/application-%DATE%.log',\n    datePattern: 'YYYY-MM-DD',\n    maxSize: '20m',\n    maxFiles: '14d',\n    format: combine(\n      timestamp(),\n      json()\n    )\n  }));\n  \n  // Archivo separado solo para errores\n  logger.add(new DailyRotateFile({\n    filename: 'logs/error-%DATE%.log',\n    datePattern: 'YYYY-MM-DD',\n    level: 'error',\n    maxSize: '20m',\n    maxFiles: '30d',\n    format: combine(\n      timestamp(),\n      json()\n    )\n  }));\n}\n\n// Crear middleware para logging de solicitudes HTTP\nconst loggerMiddleware = (req, res, next) => {\n  // Añadir ID único a cada solicitud\n  if (!req.id) {\n    req.id = uuidv4();\n    res.setHeader('X-Request-ID', req.id);\n  }\n  \n  // Registrar inicio de solicitud\n  logger.info(`${req.method} ${req.originalUrl}`, {\n    requestId: req.id,\n    userId: req.user?.id,\n    method: req.method,\n    path: req.originalUrl,\n    ip: req.ip,\n    userAgent: req.get('User-Agent')\n  });\n  \n  // Registrar tiempo de respuesta al finalizar\n  const startTime = Date.now();\n  res.on('finish', () => {\n    const duration = Date.now() - startTime;\n    const level = res.statusCode >= 400 ? 'warn' : 'info';\n    \n    logger[level](`${req.method} ${req.originalUrl} ${res.statusCode} - ${duration}ms`, {\n      requestId: req.id,\n      userId: req.user?.id,\n      method: req.method,\n      path: req.originalUrl,\n      statusCode: res.statusCode,\n      duration,\n      contentLength: res.get('Content-Length')\n    });\n  });\n  \n  next();\n};\n\n// Función para sanitizar datos sensibles antes de loguear\nconst sanitizeData = (data) => {\n  if (!data) return data;\n  \n  // Crear copia profunda para no modificar original\n  const sanitized = JSON.parse(JSON.stringify(data));\n  \n  // Lista de campos sensibles a ocultar\n  const sensitiveFields = [\n    'password', 'passwordHash', 'token', 'secret', \n    'authorization', 'cardNumber', 'cvv', 'ssn',\n    'creditCard', 'socialSecurityNumber'\n  ];\n  \n  const sanitizeObject = (obj) => {\n    for (const key in obj) {\n      // Verificar si es campo sensible\n      if (sensitiveFields.some(field => key.toLowerCase().includes(field.toLowerCase()))) {\n        obj[key] = '***REDACTED***';\n      } \n      // Recursión para objetos anidados\n      else if (obj[key] && typeof obj[key] === 'object') {\n        sanitizeObject(obj[key]);\n      }\n    }\n  };\n  \n  sanitizeObject(sanitized);\n  return sanitized;\n};\n\n// Configuración en Express\nconst express = require('express');\nconst app = express();\n\n// Middleware para generar ID único para cada solicitud\napp.use(requestId);\n\n// Middleware de logging\napp.use(loggerMiddleware);\n\n// Middleware para manejar errores\napp.use((err, req, res, next) => {\n  // Loguear error con nivel adecuado\n  const statusCode = err.statusCode || 500;\n  const logLevel = statusCode >= 500 ? 'error' : 'warn';\n  \n  logger[logLevel](`Error: ${err.message}`, {\n    requestId: req.id,\n    userId: req.user?.id,\n    method: req.method,\n    path: req.originalUrl,\n    statusCode,\n    errorCode: err.errorCode,\n    stack: process.env.NODE_ENV === 'production' ? undefined : err.stack\n  });\n  \n  // Continuar con el manejador de errores principal\n  next(err);\n});\n\n// Exportar logger para uso en toda la aplicación\nmodule.exports = { logger, sanitizeData };\n\n// Ejemplo de uso en un controlador\nconst createUser = async (req, res, next) => {\n  try {\n    logger.debug('Iniciando creación de usuario', {\n      requestId: req.id,\n      // Sanitizar datos sensibles antes de loguear\n      payload: sanitizeData(req.body)\n    });\n    \n    // Lógica de creación de usuario\n    const user = await User.create(req.body);\n    \n    logger.info('Usuario creado exitosamente', {\n      requestId: req.id,\n      userId: user.id\n    });\n    \n    res.status(201).json({ status: 'success', data: { user } });\n  } catch (error) {\n    next(error);\n  }\n};"
        }
      ],
      "relatedInstructions": ["back010", "back012"]
    },
    {
      "id": "back012",
      "title": {
        "es": "Implementar validación de datos robusta",
        "en": "Implement robust data validation"
      },
      "description": {
        "es": "Validar rigurosamente todas las entradas de datos",
        "en": "Rigorously validate all data inputs"
      },
      "text": {
        "es": "Implementa validación rigurosa de todas las entradas de datos para mejorar la robustez y seguridad de tu aplicación. Valida datos tanto en el cliente como en el servidor, utiliza bibliotecas de validación establecidas, define reglas de validación claras para cada campo, proporciona mensajes de error específicos y útiles, y verifica no solo el formato sino también las reglas de negocio. Implementa validación tanto para parámetros de ruta y consulta como para cuerpos de solicitud.",
        "en": "Implement rigorous validation of all data inputs to improve the robustness and security of your application. Validate data on both client and server sides, use established validation libraries, define clear validation rules for each field, provide specific and helpful error messages, and verify not just format but also business rules. Implement validation for route and query parameters as well as request bodies."
      },
      "importance": "high",
      "category": "error_handling",
      "subcategory": "validation",
      "tags": ["backend", "security", "data_quality"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Input Validation section"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Ejemplo de validación de datos en Express con express-validator",
            "en": "Example of data validation in Express with express-validator"
          },
          "code": "// Validación de datos en Express con express-validator\nconst express = require('express');\nconst { body, param, query, validationResult } = require('express-validator');\n\nconst app = express();\napp.use(express.json());\n\n// Middleware para manejar errores de validación\nconst validate = validations => {\n  return async (req, res, next) => {\n    // Ejecutar todas las validaciones\n    await Promise.all(validations.map(validation => validation.run(req)));\n\n    const errors = validationResult(req);\n    if (errors.isEmpty()) {\n      return next();\n    }\n\n    // Formatear errores de validación\n    const extractedErrors = errors.array().map(err => ({\n      field: err.param,\n      message: err.msg,\n      value: err.value\n    }));\n\n    return res.status(400).json({\n      status: 'error',\n      code: 'VALIDATION_ERROR',\n      message: 'Datos de entrada inválidos',\n      errors: extractedErrors\n    });\n  };\n};\n\n// Validaciones para registro de usuario\nconst userRegistrationValidations = [\n  body('email')\n    .notEmpty().withMessage('El email es requerido')\n    .isEmail().withMessage('Debe proporcionar un email válido')\n    .normalizeEmail() // Normalizar email (lowercase, eliminar espacios)\n    .custom(async value => {\n      // Validación personalizada: email único\n      const existingUser = await User.findOne({ email: value });\n      if (existingUser) {\n        throw new Error('Este email ya está en uso');\n      }\n      return true;\n    }),\n  \n  body('password')\n    .notEmpty().withMessage('La contraseña es requerida')\n    .isLength({ min: 8 }).withMessage('La contraseña debe tener al menos 8 caracteres')\n    .matches(/[a-z]/).withMessage('La contraseña debe contener al menos una letra minúscula')\n    .matches(/[A-Z]/).withMessage('La contraseña debe contener al menos una letra mayúscula')\n    .matches(/[0-9]/).withMessage('La contraseña debe contener al menos un número')\n    .matches(/[^a-zA-Z0-9]/).withMessage('La contraseña debe contener al menos un carácter especial'),\n  \n  body('confirmPassword')\n    .notEmpty().withMessage('La confirmación de contraseña es requerida')\n    .custom((value, { req }) => {\n      if (value !== req.body.password) {\n        throw new Error('Las contraseñas no coinciden');\n      }\n      return true;\n    }),\n  \n  body('username')\n    .notEmpty().withMessage('El nombre de usuario es requerido')\n    .isLength({ min: 3, max: 20 }).withMessage('El nombre de usuario debe tener entre 3 y 20 caracteres')\n    .matches(/^[a-zA-Z0-9_]+$/).withMessage('El nombre de usuario solo puede contener letras, números y guiones bajos')\n    .custom(async value => {\n      // Validación personalizada: username único\n      const existingUser = await User.findOne({ username: value });\n      if (existingUser) {\n        throw new Error('Este nombre de usuario ya está en uso');\n      }\n      return true;\n    }),\n  \n  body('name')\n    .optional()\n    .isLength({ max: 100 }).withMessage('El nombre completo no puede superar los 100 caracteres'),\n  \n  body('birthDate')\n    .optional()\n    .isISO8601().withMessage('La fecha de nacimiento debe estar en formato YYYY-MM-DD')\n    .toDate() // Convertir a objeto Date\n    .custom(value => {\n      // Validar mayoría de edad\n      const today = new Date();\n      const birthDate = new Date(value);\n      let age = today.getFullYear() - birthDate.getFullYear();\n      const monthDiff = today.getMonth() - birthDate.getMonth();\n      \n      if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {\n        age--;\n      }\n      \n      if (age < 18) {\n        throw new Error('Debes ser mayor de 18 años para registrarte');\n      }\n      return true;\n    })\n];\n\n// Validaciones para actualización de producto (ejemplo de validación PUT/PATCH)\nconst productUpdateValidations = [\n  param('id')\n    .isMongoId().withMessage('ID de producto inválido'),\n  \n  body('name')\n    .optional()\n    .notEmpty().withMessage('El nombre no puede estar vacío')\n    .isLength({ max: 200 }).withMessage('El nombre no puede superar los 200 caracteres'),\n  \n  body('price')\n    .optional()\n    .isFloat({ min: 0.01 }).withMessage('El precio debe ser un número mayor a 0')\n    .toFloat(), // Convertir a número\n  \n  body('description')\n    .optional()\n    .isLength({ max: 2000 }).withMessage('La descripción no puede superar los 2000 caracteres'),\n  \n  body('category')\n    .optional()\n    .isMongoId().withMessage('ID de categoría inválido')\n    .custom(async value => {\n      // Verificar que la categoría existe\n      const category = await Category.findById(value);\n      if (!category) {\n        throw new Error('La categoría seleccionada no existe');\n      }\n      return true;\n    }),\n  \n  body('tags')\n    .optional()\n    .isArray().withMessage('Los tags deben ser un array')\n    .custom(value => {\n      if (!Array.isArray(value)) return false;\n      // Verificar que cada tag es un string y no está vacío\n      return value.every(tag => typeof tag === 'string' && tag.trim().length > 0);\n    }).withMessage('Cada tag debe ser texto no vacío'),\n  \n  body('stock')\n    .optional()\n    .isInt({ min: 0 }).withMessage('El stock debe ser un número entero no negativo')\n    .toInt() // Convertir a entero\n];\n\n// Validaciones para parámetros de consulta en listado\nconst productListValidations = [\n  query('page')\n    .optional()\n    .isInt({ min: 1 }).withMessage('El número de página debe ser un entero positivo')\n    .toInt(),\n  \n  query('limit')\n    .optional()\n    .isInt({ min: 1, max: 100 }).withMessage('El límite debe ser un entero entre 1 y 100')\n    .toInt(),\n  \n  query('sort')\n    .optional()\n    .isIn(['price_asc', 'price_desc', 'name_asc', 'name_desc', 'newest'])\n    .withMessage('Criterio de ordenación no válido'),\n  \n  query('minPrice')\n    .optional()\n    .isFloat({ min: 0 }).withMessage('El precio mínimo debe ser un número no negativo')\n    .toFloat(),\n  \n  query('maxPrice')\n    .optional()\n    .isFloat({ min: 0 }).withMessage('El precio máximo debe ser un número no negativo')\n    .toFloat()\n    .custom((value, { req }) => {\n      // Validar que maxPrice > minPrice si ambos están presentes\n      if (req.query.minPrice && parseFloat(value) <= parseFloat(req.query.minPrice)) {\n        throw new Error('El precio máximo debe ser mayor que el precio mínimo');\n      }\n      return true;\n    })\n];\n\n// Rutas con validación\napp.post('/api/users/register', validate(userRegistrationValidations), userController.register);\n\napp.put('/api/products/:id', validate(productUpdateValidations), productController.update);\n\napp.get('/api/products', validate(productListValidations), productController.list);\n\n// Exportar middleware de validación para uso en toda la aplicación\nmodule.exports = { validate };"
        }
      ],
      "relatedInstructions": ["sec001", "back010"]
    }
  ]
}
