{
  "components": [
    {
      "id": "react001",
      "title": {
        "es": "Organización modular de componentes",
        "en": "Modular component organization"
      },
      "description": {
        "es": "Estructurar componentes en archivos separados para mejorar mantenibilidad",
        "en": "Structure components in separate files to improve maintainability"
      },
      "text": {
        "es": "Organiza los componentes React en archivos separados siguiendo el principio de responsabilidad única. Cada componente debe tener su propio archivo, incluso si es pequeño, para facilitar la navegación por el código, mejorar la reutilización y permitir un testing más específico. Agrupa los componentes relacionados en directorios temáticos y considera implementar una estructura de 'componentes de características' para proyectos más grandes.",
        "en": "Organize React components in separate files following the single responsibility principle. Each component should have its own file, even if small, to facilitate code navigation, improve reusability, and allow for more targeted testing. Group related components in thematic directories and consider implementing a 'feature components' structure for larger projects."
      },
      "importance": "high",
      "category": "components",
      "subcategory": "organization",
      "tags": ["frontend", "react", "architecture"],
      "source": {
        "agentType": "same.dev",
        "repository": "Same.dev/Prompt.txt",
        "context": "Coding Guidelines section"
      },
      "compatibility": {
        "frameworks": ["react", "nextjs", "gatsby"],
        "languages": ["javascript", "typescript"],
        "environments": ["web"]
      },
      "examples": [
        {
          "context": {
            "es": "Estructura de archivos para componentes en una aplicación React",
            "en": "File structure for components in a React application"
          },
          "code": "// Ejemplo de estructura de directorios para una aplicación React\n\nsrc/\n  components/\n    common/\n      Button.jsx\n      Card.jsx\n      Input.jsx\n    layout/\n      Header.jsx\n      Footer.jsx\n      Sidebar.jsx\n    features/\n      authentication/\n        LoginForm.jsx\n        SignupForm.jsx\n        ResetPasswordForm.jsx\n      product/\n        ProductCard.jsx\n        ProductList.jsx\n        ProductDetail.jsx\n\n// Button.jsx - Ejemplo de un componente simple en su propio archivo\nimport React from 'react';\n\nconst Button = ({ text, onClick, variant = 'primary', disabled = false }) => {\n  return (\n    <button\n      className={`btn btn-${variant}`}\n      onClick={onClick}\n      disabled={disabled}\n    >\n      {text}\n    </button>\n  );\n};\n\nexport default Button;\n\n// ProductCard.jsx - Ejemplo de un componente de característica\nimport React from 'react';\nimport { Link } from 'react-router-dom';\nimport { Card, Button } from '../common';\nimport { formatPrice } from '../../utils/formatters';\n\nconst ProductCard = ({ product, onAddToCart }) => {\n  const { id, name, price, imageUrl, inStock } = product;\n  \n  return (\n    <Card>\n      <img src={imageUrl} alt={name} className=\"product-image\" />\n      <h3>{name}</h3>\n      <p className=\"price\">{formatPrice(price)}</p>\n      <div className=\"actions\">\n        <Link to={`/products/${id}`}>View Details</Link>\n        <Button \n          text=\"Add to Cart\" \n          onClick={() => onAddToCart(id)}\n          disabled={!inStock}\n          variant={inStock ? 'primary' : 'disabled'}\n        />\n      </div>\n    </Card>\n  );\n};\n\nexport default ProductCard;"
        }
      ],
      "relatedInstructions": ["react002", "react003"]
    },
    {
      "id": "react002",
      "title": {
        "es": "Limitación del tamaño de componentes",
        "en": "Component size limitation"
      },
      "description": {
        "es": "Mantener componentes pequeños y enfocados en una sola responsabilidad",
        "en": "Keep components small and focused on a single responsibility"
      },
      "text": {
        "es": "Limita el tamaño de tus componentes React a 50 líneas o menos cuando sea posible. Los componentes más pequeños son más fáciles de entender, mantener, probar y reutilizar. Si un componente crece demasiado, considera refactorizarlo en múltiples componentes más pequeños con responsabilidades bien definidas. Esta práctica mejora la legibilidad del código y facilita la colaboración entre desarrolladores.",
        "en": "Limit the size of your React components to 50 lines or less when possible. Smaller components are easier to understand, maintain, test, and reuse. If a component grows too large, consider refactoring it into multiple smaller components with well-defined responsibilities. This practice improves code readability and facilitates collaboration between developers."
      },
      "importance": "medium",
      "category": "components",
      "subcategory": "design",
      "tags": ["frontend", "react", "code_quality"],
      "source": {
        "agentType": "same.dev",
        "repository": "Same.dev/Prompt.txt",
        "context": "Coding Guidelines section"
      },
      "compatibility": {
        "frameworks": ["react", "nextjs", "gatsby"],
        "languages": ["javascript", "typescript"],
        "environments": ["web"]
      },
      "examples": [
        {
          "context": {
            "es": "Refactorización de un componente grande en varios más pequeños",
            "en": "Refactoring a large component into several smaller ones"
          },
          "code": "// Antes: Un componente grande y difícil de mantener (UserProfile.jsx)\nimport React, { useState, useEffect } from 'react';\nimport { fetchUserData, updateUserData } from '../api/userApi';\n\nconst UserProfile = ({ userId }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [editing, setEditing] = useState(false);\n  const [formData, setFormData] = useState({});\n  \n  useEffect(() => {\n    const loadUser = async () => {\n      try {\n        setLoading(true);\n        const userData = await fetchUserData(userId);\n        setUser(userData);\n        setFormData(userData);\n        setError(null);\n      } catch (err) {\n        setError('Failed to load user data');\n        console.error(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadUser();\n  }, [userId]);\n  \n  const handleInputChange = (e) => {\n    const { name, value } = e.target;\n    setFormData({ ...formData, [name]: value });\n  };\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      setLoading(true);\n      await updateUserData(userId, formData);\n      setUser(formData);\n      setEditing(false);\n      setError(null);\n    } catch (err) {\n      setError('Failed to update user data');\n      console.error(err);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  if (loading && !user) {\n    return <div className=\"loading\">Loading...</div>;\n  }\n  \n  if (error && !user) {\n    return <div className=\"error\">{error}</div>;\n  }\n  \n  return (\n    <div className=\"user-profile\">\n      <h2>User Profile</h2>\n      {editing ? (\n        <form onSubmit={handleSubmit}>\n          <div className=\"form-group\">\n            <label htmlFor=\"name\">Name</label>\n            <input\n              type=\"text\"\n              id=\"name\"\n              name=\"name\"\n              value={formData.name}\n              onChange={handleInputChange}\n              required\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"email\">Email</label>\n            <input\n              type=\"email\"\n              id=\"email\"\n              name=\"email\"\n              value={formData.email}\n              onChange={handleInputChange}\n              required\n            />\n          </div>\n          <div className=\"form-group\">\n            <label htmlFor=\"bio\">Bio</label>\n            <textarea\n              id=\"bio\"\n              name=\"bio\"\n              value={formData.bio}\n              onChange={handleInputChange}\n            />\n          </div>\n          <div className=\"form-actions\">\n            <button type=\"submit\" disabled={loading}>Save</button>\n            <button type=\"button\" onClick={() => setEditing(false)}>Cancel</button>\n          </div>\n          {error && <div className=\"error\">{error}</div>}\n        </form>\n      ) : (\n        <div className=\"user-info\">\n          <p><strong>Name:</strong> {user.name}</p>\n          <p><strong>Email:</strong> {user.email}</p>\n          <p><strong>Bio:</strong> {user.bio}</p>\n          <button onClick={() => setEditing(true)}>Edit Profile</button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default UserProfile;\n\n// Después: Componentes más pequeños y enfocados\n\n// UserProfileContainer.jsx - Componente contenedor para lógica de datos\nimport React, { useState, useEffect } from 'react';\nimport { fetchUserData, updateUserData } from '../api/userApi';\nimport UserProfileView from './UserProfileView';\nimport UserProfileForm from './UserProfileForm';\nimport LoadingSpinner from '../common/LoadingSpinner';\nimport ErrorMessage from '../common/ErrorMessage';\n\nconst UserProfileContainer = ({ userId }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [editing, setEditing] = useState(false);\n  \n  useEffect(() => {\n    loadUser();\n  }, [userId]);\n  \n  const loadUser = async () => {\n    try {\n      setLoading(true);\n      const userData = await fetchUserData(userId);\n      setUser(userData);\n      setError(null);\n    } catch (err) {\n      setError('Failed to load user data');\n      console.error(err);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const handleSave = async (formData) => {\n    try {\n      setLoading(true);\n      await updateUserData(userId, formData);\n      setUser(formData);\n      setEditing(false);\n      setError(null);\n    } catch (err) {\n      setError('Failed to update user data');\n      console.error(err);\n      return false;\n    } finally {\n      setLoading(false);\n    }\n    return true;\n  };\n  \n  if (loading && !user) {\n    return <LoadingSpinner />;\n  }\n  \n  if (error && !user) {\n    return <ErrorMessage message={error} />;\n  }\n  \n  return editing ? (\n    <UserProfileForm \n      initialData={user} \n      onSave={handleSave} \n      onCancel={() => setEditing(false)} \n      loading={loading}\n      error={error}\n    />\n  ) : (\n    <UserProfileView \n      user={user} \n      onEdit={() => setEditing(true)} \n    />\n  );\n};\n\nexport default UserProfileContainer;\n\n// UserProfileView.jsx - Componente de presentación simple\nimport React from 'react';\n\nconst UserProfileView = ({ user, onEdit }) => {\n  return (\n    <div className=\"user-profile\">\n      <h2>User Profile</h2>\n      <div className=\"user-info\">\n        <p><strong>Name:</strong> {user.name}</p>\n        <p><strong>Email:</strong> {user.email}</p>\n        <p><strong>Bio:</strong> {user.bio}</p>\n        <button onClick={onEdit}>Edit Profile</button>\n      </div>\n    </div>\n  );\n};\n\nexport default UserProfileView;\n\n// UserProfileForm.jsx - Componente de formulario\nimport React, { useState } from 'react';\nimport ErrorMessage from '../common/ErrorMessage';\n\nconst UserProfileForm = ({ initialData, onSave, onCancel, loading, error }) => {\n  const [formData, setFormData] = useState(initialData);\n  \n  const handleInputChange = (e) => {\n    const { name, value } = e.target;\n    setFormData({ ...formData, [name]: value });\n  };\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    await onSave(formData);\n  };\n  \n  return (\n    <div className=\"user-profile\">\n      <h2>Edit Profile</h2>\n      <form onSubmit={handleSubmit}>\n        <div className=\"form-group\">\n          <label htmlFor=\"name\">Name</label>\n          <input\n            type=\"text\"\n            id=\"name\"\n            name=\"name\"\n            value={formData.name}\n            onChange={handleInputChange}\n            required\n          />\n        </div>\n        <div className=\"form-group\">\n          <label htmlFor=\"email\">Email</label>\n          <input\n            type=\"email\"\n            id=\"email\"\n            name=\"email\"\n            value={formData.email}\n            onChange={handleInputChange}\n            required\n          />\n        </div>\n        <div className=\"form-group\">\n          <label htmlFor=\"bio\">Bio</label>\n          <textarea\n            id=\"bio\"\n            name=\"bio\"\n            value={formData.bio}\n            onChange={handleInputChange}\n          />\n        </div>\n        <div className=\"form-actions\">\n          <button type=\"submit\" disabled={loading}>Save</button>\n          <button type=\"button\" onClick={onCancel}>Cancel</button>\n        </div>\n        {error && <ErrorMessage message={error} />}\n      </form>\n    </div>\n  );\n};\n\nexport default UserProfileForm;"
        }
      ],
      "relatedInstructions": ["react001", "react003"]
    },
    {
      "id": "react003",
      "title": {
        "es": "Uso de componentes funcionales con hooks",
        "en": "Use functional components with hooks"
      },
      "description": {
        "es": "Preferir componentes funcionales con hooks sobre componentes de clase",
        "en": "Prefer functional components with hooks over class components"
      },
      "text": {
        "es": "Utiliza componentes funcionales con hooks en lugar de componentes de clase en tus proyectos React. Los componentes funcionales son más concisos, fáciles de leer y mantener, y generan un código más limpio. Los hooks como useState, useEffect, useContext y useReducer proporcionan toda la funcionalidad que antes requería clases, pero con una API más intuitiva y composición más sencilla. Esta práctica está alineada con la dirección actual del desarrollo en React.",
        "en": "Use functional components with hooks instead of class components in your React projects. Functional components are more concise, easier to read and maintain, and result in cleaner code. Hooks like useState, useEffect, useContext, and useReducer provide all the functionality that previously required classes, but with a more intuitive API and simpler composition. This practice aligns with the current direction of React development."
      },
      "importance": "high",
      "category": "components",
      "subcategory": "paradigm",
      "tags": ["frontend", "react", "hooks"],
      "source": {
        "agentType": "windsurf",
        "repository": "Windsurf/Windsurf.txt",
        "context": "Web Development section"
      },
      "compatibility": {
        "frameworks": ["react", "nextjs", "gatsby"],
        "languages": ["javascript", "typescript"],
        "environments": ["web"]
      },
      "examples": [
        {
          "context": {
            "es": "Comparación entre componente de clase y funcional con hooks",
            "en": "Comparison between class component and functional component with hooks"
          },
          "code": "// Componente de clase (enfoque antiguo)\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n    this.increment = this.increment.bind(this);\n    this.decrement = this.decrement.bind(this);\n  }\n  \n  componentDidMount() {\n    document.title = `Count: ${this.state.count}`;\n  }\n  \n  componentDidUpdate() {\n    document.title = `Count: ${this.state.count}`;\n  }\n  \n  increment() {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  }\n  \n  decrement() {\n    this.setState(prevState => ({\n      count: prevState.count - 1\n    }));\n  }\n  \n  render() {\n    return (\n      <div className=\"counter\">\n        <h2>Counter: {this.state.count}</h2>\n        <button onClick={this.decrement}>-</button>\n        <button onClick={this.increment}>+</button>\n      </div>\n    );\n  }\n}\n\n// Componente funcional con hooks (enfoque moderno)\nimport React, { useState, useEffect } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]); // Solo se ejecuta cuando count cambia\n  \n  const increment = () => setCount(prevCount => prevCount + 1);\n  const decrement = () => setCount(prevCount => prevCount - 1);\n  \n  return (\n    <div className=\"counter\">\n      <h2>Counter: {count}</h2>\n      <button onClick={decrement}>-</button>\n      <button onClick={increment}>+</button>\n    </div>\n  );\n};\n\nexport default Counter;"
        }
      ],
      "relatedInstructions": ["react001", "react002", "react004"]
    }
  ]
}