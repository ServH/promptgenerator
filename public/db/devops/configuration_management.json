{
  "instructions": [
    {
      "id": "cm001",
      "title": {
        "es": "Implementar infraestructura como código (IaC)",
        "en": "Implement Infrastructure as Code (IaC)"
      },
      "description": {
        "es": "Gestionar la infraestructura mediante archivos de configuración versionados",
        "en": "Manage infrastructure through versioned configuration files"
      },
      "text": {
        "es": "Implementa prácticas de Infraestructura como Código (IaC) para definir y gestionar toda la infraestructura mediante archivos de configuración versionados. Utiliza herramientas como Terraform, AWS CloudFormation, o Pulumi para describir declarativamente los recursos necesarios y su configuración, permitiendo así un aprovisionamiento repetible, auditable y seguro de entornos completos.",
        "en": "Implement Infrastructure as Code (IaC) practices to define and manage all infrastructure through versioned configuration files. Use tools like Terraform, AWS CloudFormation, or Pulumi to declaratively describe the required resources and their configuration, thus enabling repeatable, auditable, and secure provisioning of complete environments."
      },
      "importance": "high",
      "category": "configuration_management",
      "subcategory": "infrastructure",
      "tags": ["automation", "versioning", "consistency"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Configuration Management Best Practices"
      },
      "compatibility": {
        "frameworks": ["terraform", "cloudformation", "pulumi", "ansible"],
        "languages": ["hcl", "yaml", "json", "python"],
        "environments": ["cloud", "hybrid"]
      },
      "examples": [
        {
          "context": {
            "es": "Definición de una red virtual en AWS usando Terraform",
            "en": "Defining a virtual network in AWS using Terraform"
          },
          "code": "# Ejemplo de código Terraform para definir una VPC en AWS\n# Archivo: network.tf\n\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = \"10.0.0.0/16\"\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name        = \"${var.project}-${var.environment}-vpc\"\n    Environment = var.environment\n    Project     = var.project\n    Terraform   = \"true\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  count             = length(var.availability_zones)\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(\"10.0.0.0/16\", 8, count.index)\n  availability_zone = var.availability_zones[count.index]\n\n  tags = {\n    Name        = \"${var.project}-${var.environment}-public-${count.index + 1}\"\n    Environment = var.environment\n    Project     = var.project\n    Terraform   = \"true\"\n    Type        = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  count             = length(var.availability_zones)\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(\"10.0.0.0/16\", 8, count.index + 100)\n  availability_zone = var.availability_zones[count.index]\n\n  tags = {\n    Name        = \"${var.project}-${var.environment}-private-${count.index + 1}\"\n    Environment = var.environment\n    Project     = var.project\n    Terraform   = \"true\"\n    Type        = \"private\"\n  }\n}\n\n# Variables y otros recursos relacionados...\n"
        }
      ],
      "relatedInstructions": ["cm002", "cm003", "infra001"]
    },
    {
      "id": "cm002",
      "title": {
        "es": "Usar control de versiones para configuraciones",
        "en": "Use version control for configurations"
      },
      "description": {
        "es": "Mantener todos los archivos de configuración en un sistema de control de versiones",
        "en": "Keep all configuration files in a version control system"
      },
      "text": {
        "es": "Mantén todos los archivos de configuración, plantillas y scripts de automatización en un sistema de control de versiones como Git. Esto proporciona un historial completo de cambios, facilita la colaboración, permite revisiones por pares, y habilita la posibilidad de revertir a estados anteriores. Organiza los repositorios de manera lógica por aplicación, entorno o función para facilitar su mantenimiento.",
        "en": "Keep all configuration files, templates, and automation scripts in a version control system like Git. This provides a complete history of changes, facilitates collaboration, enables peer reviews, and allows for rollbacks to previous states. Organize repositories logically by application, environment, or function to facilitate maintenance."
      },
      "importance": "high",
      "category": "configuration_management",
      "subcategory": "versioning",
      "tags": ["git", "traceability", "collaboration"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Version Control Best Practices"
      },
      "compatibility": {
        "frameworks": ["git", "svn", "mercurial"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Estructura de repositorio Git para configuraciones de infraestructura",
            "en": "Git repository structure for infrastructure configurations"
          },
          "code": "# Ejemplo de estructura de un repositorio Git para IaC con Terraform\n\ninfrastructure-repo/\n├── README.md                     # Documentación principal del repositorio\n├── .gitignore                    # Configuración de archivos a ignorar\n├── environments/                 # Definiciones específicas por entorno\n│   ├── development/              # Entorno de desarrollo\n│   │   ├── main.tf               # Entrada principal para Terraform\n│   │   ├── variables.tf          # Variables específicas de desarrollo\n│   │   └── terraform.tfvars      # Valores concretos para variables (gitignore)\n│   ├── staging/                  # Entorno de pruebas\n│   │   ├── main.tf\n│   │   ├── variables.tf\n│   │   └── terraform.tfvars\n│   └── production/               # Entorno de producción\n│       ├── main.tf\n│       ├── variables.tf\n│       └── terraform.tfvars\n├── modules/                      # Módulos reutilizables\n│   ├── networking/               # Módulo para configuración de red\n│   │   ├── main.tf\n│   │   ├── variables.tf\n│   │   └── outputs.tf\n│   ├── compute/                  # Módulo para recursos de computación\n│   │   ├── main.tf\n│   │   ├── variables.tf\n│   │   └── outputs.tf\n│   └── database/                 # Módulo para bases de datos\n│       ├── main.tf\n│       ├── variables.tf\n│       └── outputs.tf\n├── scripts/                      # Scripts de automatización\n│   ├── apply.sh                  # Script para aplicar cambios\n│   └── validate.sh               # Script para validar configuraciones\n└── .github/                      # Configuración de CI/CD\n    └── workflows/\n        ├── validate.yml          # Validación automática en PR\n        └── apply.yml             # Despliegue automático en merge\n\n# También se recomienda incluir:\n# - CHANGELOG.md                  # Registro de cambios\n# - CONTRIBUTING.md               # Guía para contribuir al repositorio\n# - .pre-commit-config.yaml       # Configuración para hooks de pre-commit\n# - backend.tf                    # Configuración del backend para Terraform"
        }
      ],
      "relatedInstructions": ["cm001", "cm005", "ci002"]
    },
    {
      "id": "cm003",
      "title": {
        "es": "Adoptar configuración inmutable",
        "en": "Adopt immutable configuration"
      },
      "description": {
        "es": "Implementar el principio de inmutabilidad en la configuración de servidores e infraestructura",
        "en": "Implement the principle of immutability for server and infrastructure configuration"
      },
      "text": {
        "es": "Implementa el principio de inmutabilidad en la configuración de infraestructura, donde los servidores y componentes no se modifican después de su despliegue. En lugar de actualizar componentes existentes, crea nuevas instancias con la configuración actualizada y reemplaza las anteriores. Este enfoque mejora la consistencia, simplifica las reversiones y elimina la desviación de configuración.",
        "en": "Implement the principle of immutability in infrastructure configuration, where servers and components are not modified after deployment. Instead of updating existing components, create new instances with the updated configuration and replace the previous ones. This approach improves consistency, simplifies rollbacks, and eliminates configuration drift."
      },
      "importance": "high",
      "category": "configuration_management",
      "subcategory": "principles",
      "tags": ["immutability", "consistency", "deployment"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Infrastructure Design Patterns"
      },
      "compatibility": {
        "frameworks": ["terraform", "cloudformation", "kubernetes", "docker"],
        "languages": ["all"],
        "environments": ["cloud", "containerized"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementación de inmutabilidad con imágenes de contenedores",
            "en": "Implementing immutability with container images"
          },
          "code": "# Ejemplo de inmutabilidad usando Docker y Kubernetes\n\n# 1. Dockerfile que crea una imagen inmutable\nFROM node:16-alpine\n\n# Establecer directorio de trabajo\nWORKDIR /app\n\n# Copiar archivos de dependencias\nCOPY package*.json ./\n\n# Instalar dependencias\nRUN npm ci --only=production\n\n# Copiar código fuente\nCOPY src/ ./src/\n\n# Establecer usuario no privilegiado para seguridad\nUSER node\n\n# Comando para ejecutar la aplicación\nCMD [\"node\", \"src/index.js\"]\n\n\n# 2. Implementación inmutable en Kubernetes\n# archivo: deployment.yaml\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: api-service\n  labels:\n    app: api-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: api-service\n  strategy:\n    type: RollingUpdate    # Estrategia para reemplazar pods\n    rollingUpdate:\n      maxSurge: 1          # Máximo de pods adicionales\n      maxUnavailable: 0    # No permitir indisponibilidad durante actualización\n  template:\n    metadata:\n      labels:\n        app: api-service\n    spec:\n      containers:\n      - name: api\n        image: company/api-service:1.2.3  # Versión específica e inmutable\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 3000\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        resources:\n          limits:\n            cpu: \"500m\"\n            memory: \"512Mi\"\n          requests:\n            cpu: \"200m\"\n            memory: \"256Mi\"\n        readinessProbe:     # Verificar si el pod está listo\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 10\n\n# 3. Flujo de CI/CD para inmutabilidad\n# - Versiones inmutables para cada build\n# - Testeo completo antes de despliegue\n# - Actualización mediante reemplazo, no modificación\n# - Capacidad de rollback inmediato a versión anterior"
        }
      ],
      "relatedInstructions": ["cm001", "cm004", "cont001"]
    },
    {
      "id": "cm004",
      "title": {
        "es": "Implementar gestión de secretos",
        "en": "Implement secrets management"
      },
      "description": {
        "es": "Utilizar soluciones seguras para gestionar credenciales y configuraciones sensibles",
        "en": "Use secure solutions to manage credentials and sensitive configurations"
      },
      "text": {
        "es": "Implementa una solución robusta de gestión de secretos para manejar credenciales, claves de API, certificados y otras configuraciones sensibles. Nunca almacenes secretos en código fuente o repositorios, incluso en repositorios privados. Utiliza servicios especializados como HashiCorp Vault, AWS Secrets Manager, o herramientas de gestión de secretos de Kubernetes para cifrar, controlar acceso y versionar de forma segura la información confidencial.",
        "en": "Implement a robust secrets management solution to handle credentials, API keys, certificates, and other sensitive configurations. Never store secrets in source code or repositories, even private ones. Use specialized services like HashiCorp Vault, AWS Secrets Manager, or Kubernetes secrets management tools to encrypt, access-control, and securely version confidential information."
      },
      "importance": "high",
      "category": "configuration_management",
      "subcategory": "security",
      "tags": ["secrets", "credentials", "security"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Security Best Practices"
      },
      "compatibility": {
        "frameworks": ["vault", "aws_secrets_manager", "azure_key_vault", "kubernetes_secrets"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Integración de HashiCorp Vault con una aplicación",
            "en": "Integrating HashiCorp Vault with an application"
          },
          "code": "# Ejemplo de implementación de gestión de secretos con HashiCorp Vault\n\n# 1. Configuración del cliente Vault en una aplicación Node.js\n\n// Archivo: src/services/secrets.js\nconst vault = require('node-vault')();\n\nasync function getSecret(path) {\n  try {\n    // Obtener token de autenticación (desde variable de entorno o archivo)\n    const token = process.env.VAULT_TOKEN;\n    vault.token = token;\n    \n    // Leer el secreto desde Vault\n    const result = await vault.read(`secret/data/${path}`);\n    return result.data.data;\n  } catch (error) {\n    console.error(`Error retrieving secret from path ${path}:`, error.message);\n    throw new Error(`Failed to retrieve secret: ${error.message}`);\n  }\n}\n\n// Uso en la aplicación\nasync function initializeDatabase() {\n  try {\n    // Recuperar credenciales de base de datos desde Vault\n    const dbCredentials = await getSecret('database/credentials');\n    \n    // Usar las credenciales para la conexión a la base de datos\n    const connection = await connectToDatabase({\n      host: process.env.DB_HOST, // No-sensible config en variables de entorno\n      port: process.env.DB_PORT,\n      username: dbCredentials.username, // Sensible desde Vault\n      password: dbCredentials.password  // Sensible desde Vault\n    });\n    \n    return connection;\n  } catch (error) {\n    console.error('Failed to initialize database:', error);\n    process.exit(1);\n  }\n}\n\n# 2. Configuración en Kubernetes usando Vault\n# Archivo: deployment.yaml con anotaciones para inyección de secretos\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: api-service\nspec:\n  replicas: 3\n  template:\n    metadata:\n      annotations:\n        vault.hashicorp.com/agent-inject: 'true'\n        vault.hashicorp.com/role: 'api-service'\n        vault.hashicorp.com/agent-inject-secret-database-creds: 'secret/data/database/credentials'\n        vault.hashicorp.com/agent-inject-template-database-creds: |\n          {{- with secret \"secret/data/database/credentials\" -}}\n          export DB_USERNAME=\"{{ .Data.data.username }}\"\n          export DB_PASSWORD=\"{{ .Data.data.password }}\"\n          {{- end -}}\n    spec:\n      serviceAccountName: api-service-account\n      containers:\n      - name: api\n        image: company/api-service:1.2.3\n        # El sidecar de Vault inyecta los secretos como archivos\n        # que el contenedor puede cargar durante su inicio\n\n# 3. Buenas prácticas adicionales:\n# - Rotación automática de secretos\n# - Control de acceso basado en roles (RBAC)\n# - Auditoría de todos los accesos a secretos\n# - Secretos efímeros (de corta duración)\n# - Encriptación en reposo y en tránsito"
        }
      ],
      "relatedInstructions": ["cm001", "cm005", "sec003"]
    },
    {
      "id": "cm005",
      "title": {
        "es": "Separar configuración por entorno",
        "en": "Separate configuration by environment"
      },
      "description": {
        "es": "Mantener configuraciones específicas para cada entorno de manera separada",
        "en": "Maintain separate environment-specific configurations"
      },
      "text": {
        "es": "Separa claramente las configuraciones específicas para diferentes entornos (desarrollo, pruebas, staging, producción) mientras mantienes el código y la estructura base igual. Utiliza archivos de configuración diferentes, variables de entorno, o sistemas de gestión de configuración que permitan cambiar fácilmente entre entornos sin modificar el código. Esta práctica reduce los errores de despliegue y simplifica la promoción de cambios entre entornos.",
        "en": "Clearly separate configurations specific to different environments (development, testing, staging, production) while keeping the base code and structure the same. Use different configuration files, environment variables, or configuration management systems that allow easy switching between environments without modifying code. This practice reduces deployment errors and simplifies the promotion of changes between environments."
      },
      "importance": "high",
      "category": "configuration_management",
      "subcategory": "environment",
      "tags": ["environments", "separation", "deployment"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Environment Management Best Practices"
      },
      "compatibility": {
        "frameworks": ["spring", "node", "react", "terraform", "kubernetes"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Configuración separada por entorno en una aplicación Node.js",
            "en": "Environment-separated configuration in a Node.js application"
          },
          "code": "# Ejemplo de configuración separada por entorno en Node.js\n\n# 1. Estructura de directorios para configuración por entorno\nsrc/\n├── config/\n│   ├── index.js          # Carga la configuración según entorno\n│   ├── default.js        # Configuración base común a todos los entornos\n│   ├── development.js    # Desarrollo (sobrescribe valores específicos)\n│   ├── test.js           # Pruebas unitarias/integración\n│   ├── staging.js        # Entorno de pre-producción\n│   └── production.js     # Producción\n└── ...\n\n# 2. Implementación del cargador de configuración\n// src/config/index.js\nconst defaultConfig = require('./default');\nlet environmentConfig = {};\n\n// Determinar el entorno actual\nconst env = process.env.NODE_ENV || 'development';\n\n// Cargar la configuración específica del entorno\ntry {\n  environmentConfig = require(`./${env}`);\n  console.log(`Loaded configuration for ${env} environment`);\n} catch (error) {\n  console.warn(`No configuration file found for ${env}, using default only`);\n}\n\n// Combinar configuración base con la específica del entorno\nconst config = {\n  ...defaultConfig,\n  ...environmentConfig,\n  env // Incluir el nombre del entorno en la configuración\n};\n\nmodule.exports = config;\n\n# 3. Configuración base (valores por defecto)\n// src/config/default.js\nmodule.exports = {\n  server: {\n    port: 3000,\n    cors: {\n      origin: '*',\n      methods: ['GET', 'POST']\n    }\n  },\n  database: {\n    type: 'postgres',\n    host: 'localhost',\n    port: 5432,\n    name: 'app_db',\n    pool: {\n      min: 2,\n      max: 10\n    }\n  },\n  logging: {\n    level: 'info',\n    format: 'json'\n  },\n  cache: {\n    enabled: true,\n    ttl: 300 // 5 minutos\n  }\n};\n\n# 4. Configuración específica de producción\n// src/config/production.js\nmodule.exports = {\n  server: {\n    port: process.env.PORT || 8080,\n    cors: {\n      origin: ['https://app.example.com', 'https://admin.example.com'],\n      methods: ['GET', 'POST']\n    }\n  },\n  database: {\n    // Host/credenciales desde variables de entorno\n    host: process.env.DB_HOST,\n    port: parseInt(process.env.DB_PORT || '5432'),\n    name: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    pool: {\n      min: 5,\n      max: 30\n    }\n  },\n  logging: {\n    level: 'warn', // Menos verboso en producción\n    format: 'json'\n  },\n  cache: {\n    enabled: true,\n    ttl: 900 // 15 minutos - más largo en producción\n  }\n};\n\n# 5. Uso en la aplicación\n// src/server.js\nconst config = require('./config');\nconst express = require('express');\n\nconst app = express();\n\n// Usar la configuración\napp.listen(config.server.port, () => {\n  console.log(`Server running in ${config.env} mode on port ${config.server.port}`);\n});\n\n// Configuración de CORS basada en entorno\nconst cors = require('cors');\napp.use(cors(config.server.cors));\n\n// La configuración ya tiene los valores específicos del entorno"
        }
      ],
      "relatedInstructions": ["cm001", "cm006", "ci003"]
    },
    {
      "id": "cm006",
      "title": {
        "es": "Implementar infraestructura modular",
        "en": "Implement modular infrastructure"
      },
      "description": {
        "es": "Diseñar la infraestructura en módulos reutilizables y componibles",
        "en": "Design infrastructure in reusable and composable modules"
      },
      "text": {
        "es": "Estructura la infraestructura como código utilizando módulos reutilizables que encapsulen componentes específicos como redes, computación, bases de datos o seguridad. Define interfaces claras entre módulos con inputs y outputs bien documentados. Este enfoque modular promueve la reutilización, facilita el mantenimiento, y permite combinar componentes de diferentes maneras para diferentes entornos o proyectos.",
        "en": "Structure infrastructure as code using reusable modules that encapsulate specific components such as networking, compute, databases, or security. Define clear interfaces between modules with well-documented inputs and outputs. This modular approach promotes reuse, facilitates maintenance, and allows combining components in different ways for different environments or projects."
      },
      "importance": "medium",
      "category": "configuration_management",
      "subcategory": "architecture",
      "tags": ["modularity", "reusability", "maintainability"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Infrastructure Architecture Patterns"
      },
      "compatibility": {
        "frameworks": ["terraform", "cloudformation", "pulumi"],
        "languages": ["hcl", "yaml", "json", "python"],
        "environments": ["cloud", "hybrid"]
      },
      "examples": [
        {
          "context": {
            "es": "Módulo reutilizable de Terraform para base de datos",
            "en": "Reusable Terraform module for a database"
          },
          "code": "# Ejemplo de módulo de Terraform para una base de datos PostgreSQL en AWS\n# Directorio: modules/database/postgresql/\n\n# 1. Definición de variables de entrada (inputs)\n# file: variables.tf\nvariable \"identifier\" {\n  description = \"The identifier for the database instance\"\n  type        = string\n}\n\nvariable \"instance_class\" {\n  description = \"The instance type for the database\"\n  type        = string\n  default     = \"db.t3.medium\"\n}\n\nvariable \"allocated_storage\" {\n  description = \"The amount of storage (in GB) to allocate\"\n  type        = number\n  default     = 20\n}\n\nvariable \"engine_version\" {\n  description = \"The PostgreSQL engine version to use\"\n  type        = string\n  default     = \"13.4\"\n}\n\nvariable \"database_name\" {\n  description = \"The name of the database to create\"\n  type        = string\n}\n\nvariable \"username\" {\n  description = \"The master username for the database\"\n  type        = string\n  sensitive   = true\n}\n\nvariable \"password\" {\n  description = \"The master password for the database\"\n  type        = string\n  sensitive   = true\n}\n\nvariable \"subnet_ids\" {\n  description = \"The list of subnet IDs for the database subnet group\"\n  type        = list(string)\n}\n\nvariable \"vpc_security_group_ids\" {\n  description = \"The list of security group IDs for the database\"\n  type        = list(string)\n}\n\nvariable \"backup_retention_period\" {\n  description = \"The number of days to retain backups\"\n  type        = number\n  default     = 7\n}\n\nvariable \"tags\" {\n  description = \"Tags to apply to all resources\"\n  type        = map(string)\n  default     = {}\n}\n\n# 2. Definición de recursos\n# file: main.tf\nresource \"aws_db_subnet_group\" \"this\" {\n  name       = \"${var.identifier}-subnet-group\"\n  subnet_ids = var.subnet_ids\n  tags       = var.tags\n}\n\nresource \"aws_db_instance\" \"this\" {\n  identifier             = var.identifier\n  engine                 = \"postgres\"\n  engine_version         = var.engine_version\n  instance_class         = var.instance_class\n  allocated_storage      = var.allocated_storage\n  name                   = var.database_name\n  username               = var.username\n  password               = var.password\n  vpc_security_group_ids = var.vpc_security_group_ids\n  db_subnet_group_name   = aws_db_subnet_group.this.name\n  backup_retention_period = var.backup_retention_period\n  storage_encrypted      = true\n  deletion_protection    = true\n  skip_final_snapshot    = false\n  final_snapshot_identifier = \"${var.identifier}-final-snapshot\"\n  tags                   = var.tags\n}\n\n# 3. Definición de salidas (outputs)\n# file: outputs.tf\noutput \"endpoint\" {\n  description = \"The connection endpoint for the database\"\n  value       = aws_db_instance.this.endpoint\n}\n\noutput \"arn\" {\n  description = \"The ARN of the database\"\n  value       = aws_db_instance.this.arn\n}\n\noutput \"id\" {\n  description = \"The ID of the database instance\"\n  value       = aws_db_instance.this.id\n}\n\noutput \"db_name\" {\n  description = \"The database name\"\n  value       = var.database_name\n}\n\n# 4. Uso del módulo en un proyecto\n# En el directorio raíz del proyecto: main.tf\nmodule \"production_database\" {\n  source = \"./modules/database/postgresql\"\n  \n  identifier        = \"my-app-production-db\"\n  instance_class    = \"db.m5.large\"\n  allocated_storage = 50\n  engine_version    = \"13.4\"\n  database_name     = \"app_production\"\n  username          = var.db_username\n  password          = var.db_password\n  subnet_ids        = module.vpc.private_subnet_ids\n  vpc_security_group_ids = [module.security_groups.db_sg_id]\n  backup_retention_period = 14\n  \n  tags = {\n    Environment = \"production\"\n    Project     = \"my-app\"\n    Terraform   = \"true\"\n  }\n}\n\n# Uso del mismo módulo para otro entorno\nmodule \"staging_database\" {\n  source = \"./modules/database/postgresql\"\n  \n  identifier        = \"my-app-staging-db\"\n  instance_class    = \"db.t3.small\"  # Menor capacidad para staging\n  allocated_storage = 20\n  engine_version    = \"13.4\"\n  database_name     = \"app_staging\"\n  username          = var.db_username\n  password          = var.db_password\n  subnet_ids        = module.vpc.private_subnet_ids\n  vpc_security_group_ids = [module.security_groups.db_sg_id]\n  backup_retention_period = 7       # Menos días de retención\n  \n  tags = {\n    Environment = \"staging\"\n    Project     = \"my-app\"\n    Terraform   = \"true\"\n  }\n}"
        }
      ],
      "relatedInstructions": ["cm001", "cm002", "infra004"]
    },
    {
      "id": "cm007",
      "title": {
        "es": "Implementar gestión de configuración centralizada",
        "en": "Implement centralized configuration management"
      },
      "description": {
        "es": "Utilizar un sistema centralizado para gestionar configuraciones a escala",
        "en": "Use a centralized system to manage configurations at scale"
      },
      "text": {
        "es": "Implementa un sistema centralizado de gestión de configuración para mantener y distribuir configuraciones consistentes a múltiples servidores o servicios. Utiliza herramientas como Ansible, Chef, Puppet, o servicios nativos de la nube para automatizar la aplicación de configuraciones, garantizando consistencia y facilitando la administración a escala.",
        "en": "Implement a centralized configuration management system to maintain and distribute consistent configurations to multiple servers or services. Use tools like Ansible, Chef, Puppet, or cloud-native services to automate the application of configurations, ensuring consistency and facilitating administration at scale."
      },
      "importance": "medium",
      "category": "configuration_management",
      "subcategory": "tools",
      "tags": ["centralization", "automation", "scaling"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Configuration Management Tools"
      },
      "compatibility": {
        "frameworks": ["ansible", "chef", "puppet", "saltstack"],
        "languages": ["yaml", "ruby", "python"],
        "environments": ["cloud", "on-premise", "hybrid"]
      },
      "examples": [
        {
          "context": {
            "es": "Playbook de Ansible para configurar servidores web",
            "en": "Ansible playbook for configuring web servers"
          },
          "code": "# Ejemplo de playbook de Ansible para configurar servidores web Nginx\n# file: webserver.yml\n---\n- name: Configure Nginx web servers\n  hosts: webservers\n  become: true\n  vars:\n    nginx_port: 80\n    app_domain: \"example.com\"\n    enable_https: true\n    ssl_certificate: \"/etc/ssl/certs/example.com.crt\"\n    ssl_key: \"/etc/ssl/private/example.com.key\"\n    max_worker_connections: 1024\n    worker_processes: \"{{ ansible_processor_vcpus }}\"\n  \n  tasks:\n    - name: Install required packages\n      apt:\n        name:\n          - nginx\n          - certbot\n          - python3-certbot-nginx\n          - fail2ban\n        state: present\n        update_cache: yes\n      when: ansible_os_family == \"Debian\"\n    \n    - name: Install required packages (RHEL/CentOS)\n      yum:\n        name:\n          - nginx\n          - certbot-nginx\n          - fail2ban\n        state: present\n      when: ansible_os_family == \"RedHat\"\n    \n    - name: Create nginx configuration directory\n      file:\n        path: \"/etc/nginx/sites-available\"\n        state: directory\n        mode: '0755'\n      when: ansible_os_family == \"RedHat\"\n    \n    - name: Create nginx enabled sites directory\n      file:\n        path: \"/etc/nginx/sites-enabled\"\n        state: directory\n        mode: '0755'\n      when: ansible_os_family == \"RedHat\"\n    \n    - name: Configure Nginx global settings\n      template:\n        src: templates/nginx.conf.j2\n        dest: /etc/nginx/nginx.conf\n        owner: root\n        group: root\n        mode: '0644'\n      notify: restart nginx\n    \n    - name: Configure virtual host\n      template:\n        src: templates/vhost.conf.j2\n        dest: /etc/nginx/sites-available/{{ app_domain }}.conf\n        owner: root\n        group: root\n        mode: '0644'\n      notify: restart nginx\n    \n    - name: Enable virtual host\n      file:\n        src: /etc/nginx/sites-available/{{ app_domain }}.conf\n        dest: /etc/nginx/sites-enabled/{{ app_domain }}.conf\n        state: link\n      notify: restart nginx\n    \n    - name: Configure fail2ban\n      template:\n        src: templates/jail.local.j2\n        dest: /etc/fail2ban/jail.local\n        owner: root\n        group: root\n        mode: '0644'\n      notify: restart fail2ban\n    \n    - name: Ensure nginx is running and enabled\n      service:\n        name: nginx\n        state: started\n        enabled: yes\n    \n    - name: Ensure fail2ban is running and enabled\n      service:\n        name: fail2ban\n        state: started\n        enabled: yes\n    \n    - name: Obtain SSL Certificate with Certbot (if HTTPS enabled)\n      command: >\n        certbot --nginx -d {{ app_domain }} -d www.{{ app_domain }}\n        --non-interactive --agree-tos --email webmaster@{{ app_domain }}\n        --redirect\n      args:\n        creates: \"{{ ssl_certificate }}\"\n      when: enable_https\n    \n  handlers:\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n    \n    - name: restart fail2ban\n      service:\n        name: fail2ban\n        state: restarted\n\n# Archivo de template: templates/nginx.conf.j2\n# user nginx;\nworker_processes {{ worker_processes }};\n\nerror_log /var/log/nginx/error.log warn;\npid /var/run/nginx.pid;\n\nevents {\n    worker_connections {{ max_worker_connections }};\n}\n\nhttp {\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log /var/log/nginx/access.log main;\n\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65;\n    types_hash_max_size 2048;\n    server_tokens off;\n\n    # Gzip Settings\n    gzip on;\n    gzip_disable \"msie6\";\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n}"
        }
      ],
      "relatedInstructions": ["cm001", "cm005", "infra003"]
    },
    {
      "id": "cm008",
      "title": {
        "es": "Implementar validación de configuración",
        "en": "Implement configuration validation"
      },
      "description": {
        "es": "Validar automáticamente configuraciones antes de aplicarlas",
        "en": "Automatically validate configurations before applying them"
      },
      "text": {
        "es": "Implementa validación automática de configuraciones antes de su aplicación en entornos reales. Utiliza herramientas de linting, testing y validación específicas de la plataforma para detectar errores, problemas de formato, vulnerabilidades o incumplimiento de políticas. Integra estas verificaciones en el flujo de trabajo de CI/CD para prevenir despliegues con configuraciones incorrectas.",
        "en": "Implement automatic validation of configurations before they are applied to real environments. Use linting tools, testing, and platform-specific validation to detect errors, formatting issues, vulnerabilities, or policy violations. Integrate these checks into the CI/CD workflow to prevent deployments with incorrect configurations."
      },
      "importance": "medium",
      "category": "configuration_management",
      "subcategory": "validation",
      "tags": ["testing", "quality", "security"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Configuration Validation Best Practices"
      },
      "compatibility": {
        "frameworks": ["terraform", "kubernetes", "ansible", "cloudformation"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Pipeline de CI para validar configuraciones de Terraform",
            "en": "CI pipeline for validating Terraform configurations"
          },
          "code": "# Ejemplo de pipeline de CI para validación de Terraform mediante GitHub Actions\n\n# Los componentes clave incluyen:\n# 1. Triggers: Ejecutar en push a ramas principales y pull requests\n# 2. Validaciones: Formato, sintaxis, buenas prácticas y seguridad\n# 3. Herramientas utilizadas: Terraform CLI, TFLint, tfsec y Checkov\n# 4. Retroalimentación: Comentarios automáticos en PRs con resultados\n\n# El pipeline realiza las siguientes verificaciones:\n# - Formato correcto del código (terraform fmt)\n# - Validación sintáctica (terraform validate)\n# - Convenciones de codificación (TFLint)\n# - Problemas de seguridad (tfsec y Checkov)\n# - Previsualización de cambios (terraform plan)\n\n# Se generan informes en los PRs que muestran:\n# - Estado de las verificaciones de formato y validación\n# - Plan de Terraform con cambios propuestos\n# - Detalles sobre errores o advertencias encontrados\n\n# Las reglas de TFLint verifican:\n# - Variables documentadas y tipadas\n# - Convenciones de nomenclatura\n# - Versiones requeridas de Terraform y proveedores\n# - Declaraciones no utilizadas\n# - Sintaxis de comentarios correcta"
        }
      ],
      "relatedInstructions": ["cm001", "cm005", "ci001"]
    },
    {
      "id": "cm009",
      "title": {
        "es": "Implementar gestión de cambios de configuración",
        "en": "Implement configuration change management"
      },
      "description": {
        "es": "Establecer procesos formales para gestionar cambios de configuración",
        "en": "Establish formal processes for managing configuration changes"
      },
      "text": {
        "es": "Establece procesos formales para gestionar los cambios en las configuraciones de infraestructura y aplicaciones. Documenta los procedimientos de solicitud, aprobación, implementación y verificación de cambios. Utiliza herramientas de gestión de cambios integradas con el control de versiones, sistemas de tickets y CI/CD para mantener trazabilidad y cumplimiento con políticas organizacionales.",
        "en": "Establish formal processes to manage changes in infrastructure and application configurations. Document the procedures for requesting, approving, implementing, and verifying changes. Use change management tools integrated with version control, ticketing systems, and CI/CD to maintain traceability and compliance with organizational policies."
      },
      "importance": "medium",
      "category": "configuration_management",
      "subcategory": "governance",
      "tags": ["change_management", "compliance", "governance"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Change Management Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Procedimiento de gestión de cambios para infraestructura",
            "en": "Change management procedure for infrastructure"
          },
          "code": "# Estructura recomendada para un procedimiento de gestión de cambios de configuración\n\n# 1. Categorización de cambios en tres tipos según impacto y riesgo:\n#    - Cambios Estándar: Rutinarios, pre-aprobados y de bajo riesgo\n#    - Cambios Normales: Requieren evaluación formal y proceso de aprobación\n#    - Cambios de Emergencia: Para restauración de servicio, con aprobación posterior\n\n# 2. Flujo del proceso para cambios normales:\n#    - Solicitud formal (RFC) con información completa del cambio\n#    - Revisión técnica y evaluación de impacto\n#    - Aprobación según nivel de riesgo (sistema de niveles)\n#    - Implementación supervisada con plan documentado\n#    - Verificación post-implementación y validación\n#    - Documentación y cierre formal\n\n# 3. Elementos clave de una solicitud de cambio (RFC):\n#    - Información general (solicitante, sistemas afectados, fechas)\n#    - Descripción y justificación detallada\n#    - Plan de implementación paso a paso\n#    - Plan de verificación y rollback\n#    - Análisis de riesgos con mitigaciones\n\n# 4. Integración con herramientas:\n#    - Sistema de tickets (Jira/ServiceNow) para seguimiento\n#    - Control de versiones (GitHub/GitLab) para revisión de código\n#    - CI/CD para validación y aplicación automatizada\n\n# 5. Métricas de calidad para evaluar el proceso:\n#    - Porcentaje de cambios exitosos vs fallidos\n#    - Necesidad de rollback\n#    - Cumplimiento de tiempos estimados\n#    - Incidentes post-implementación"
        }
      ],
      "relatedInstructions": ["cm002", "cm008", "gov001"]
    },
    {
      "id": "cm010",
      "title": {
        "es": "Implementar registros de auditoría de configuración",
        "en": "Implement configuration audit logging"
      },
      "description": {
        "es": "Mantener registros detallados de todos los cambios de configuración",
        "en": "Maintain detailed logs of all configuration changes"
      },
      "text": {
        "es": "Implementa un sistema de registro de auditoría que capture detalladamente todos los cambios realizados en configuraciones de infraestructura y aplicaciones. Documenta quién realizó cada cambio, cuándo, qué se modificó exactamente y por qué. Estos registros deben ser inmutables, almacenarse de forma segura y retenerse según políticas de cumplimiento. Utiliza estos registros para facilitar el análisis forense en caso de incidentes y para demostrar cumplimiento normativo.",
        "en": "Implement an audit logging system that captures detailed information about all changes made to infrastructure and application configurations. Document who made each change, when, what was modified exactly, and why. These logs should be immutable, securely stored, and retained according to compliance policies. Use these logs to facilitate forensic analysis in case of incidents and to demonstrate regulatory compliance."
      },
      "importance": "medium",
      "category": "configuration_management",
      "subcategory": "compliance",
      "tags": ["audit", "logging", "compliance"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Compliance Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Sistema de registro de auditoría para cambios de infraestructura",
            "en": "Audit logging system for infrastructure changes"
          },
          "code": "# Componentes clave de un sistema de registro de auditoría para cambios de configuración:\n\n# 1. Información a capturar en cada registro:\n#    - Identificador único del cambio\n#    - Usuario/identidad que realizó el cambio\n#    - Fecha y hora exacta (con zona horaria)\n#    - Estado anterior y posterior al cambio\n#    - Método/herramienta utilizada para el cambio\n#    - ID de solicitud de cambio relacionada\n#    - Razón o justificación del cambio\n\n# 2. Características del sistema de registro:\n#    - Inmutabilidad (imposibilidad de modificación)\n#    - Integridad (hash criptográfico de registros)\n#    - Retención configurable según políticas\n#    - Búsqueda y filtrado avanzados\n#    - Control de acceso granular\n\n# 3. Implementaciones comunes:\n#    - AWS CloudTrail para cambios en la nube AWS\n#    - Azure Activity Log + Log Analytics\n#    - Evento git push con webhooks personalizados\n#    - Mecanismos de auditoria nativos de Kubernetes\n#    - Bases de datos de solo anexar (append-only)\n\n# 4. Integraciones recomendadas:\n#    - SIEM (Security Information and Event Management)\n#    - Sistemas de monitorización y alertas\n#    - Herramientas de generación de informes de cumplimiento\n#    - Sistemas de gestión de cambios\n\n# 5. Prácticas recomendadas:\n#    - Cifrado en tránsito y en reposo\n#    - Sincronización horaria precisa (NTP)\n#    - Preservación en múltiples ubicaciones\n#    - Revisiones periódicas de integridad"
        }
      ],
      "relatedInstructions": ["cm001", "cm009", "sec002"]
    }
  ]
}
