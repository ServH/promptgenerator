{
  "instructions": [
    {
      "id": "scal010",
      "title": {
        "es": "Implementar circuit breakers",
        "en": "Implement circuit breakers"
      },
      "description": {
        "es": "Usar circuit breakers para prevenir cascadas de fallos",
        "en": "Use circuit breakers to prevent cascading failures"
      },
      "text": {
        "es": "Implementa el patrón de circuit breaker para prevenir que fallos en servicios dependientes causen fallos en cascada a través del sistema. Este patrón detecta fallos y rechaza peticiones durante un período específico, permitiendo que los servicios dependientes se recuperen y evitando sobrecarga en sistemas ya comprometidos.",
        "en": "Implement the circuit breaker pattern to prevent failures in dependent services from causing cascading failures throughout the system. This pattern detects failures and rejects requests for a specific period, allowing dependent services to recover and preventing overload on already compromised systems."
      },
      "importance": "medium",
      "category": "scalability",
      "subcategory": "resilience",
      "tags": ["microservices", "resilience", "architecture"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Resilience Patterns"
      },
      "compatibility": {
        "frameworks": ["resilience4j", "hystrix", "polly", "sentinel"],
        "languages": ["java", "dotnet", "nodejs", "go"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Circuit breaker en Java con Resilience4j",
            "en": "Circuit breaker in Java with Resilience4j"
          },
          "code": "import io.github.resilience4j.circuitbreaker.CircuitBreaker;\nimport io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;\nimport io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;\n\nimport java.time.Duration;\nimport java.util.function.Supplier;\n\npublic class PaymentService {\n\n    private final ExternalPaymentGateway paymentGateway;\n    private final CircuitBreaker circuitBreaker;\n\n    public PaymentService(ExternalPaymentGateway paymentGateway) {\n        this.paymentGateway = paymentGateway;\n        \n        // Define circuit breaker configuration\n        CircuitBreakerConfig config = CircuitBreakerConfig.custom()\n            .failureRateThreshold(50)  // 50% failure rate to open circuit\n            .waitDurationInOpenState(Duration.ofSeconds(30))  // Wait 30s in OPEN state\n            .permittedNumberOfCallsInHalfOpenState(5)  // Allow 5 calls in HALF-OPEN\n            .slidingWindowSize(10)  // Look at last 10 calls to calculate failure rate\n            .recordExceptions(TimeoutException.class, IOException.class) // Which exceptions count as failures\n            .build();\n            \n        // Create the circuit breaker\n        CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(config);\n        this.circuitBreaker = registry.circuitBreaker(\"paymentService\");\n    }\n\n    public PaymentResult processPayment(Payment payment) {\n        // Decorate the function call with circuit breaker\n        Supplier<PaymentResult> decoratedSupplier = CircuitBreaker\n            .decorateSupplier(circuitBreaker, () -> paymentGateway.processPayment(payment));\n            \n        try {\n            // Execute the decorated function\n            return decoratedSupplier.get();\n        } catch (Exception e) {\n            // Handle the exception (circuit open or actual failure)\n            return new PaymentResult(PaymentStatus.FAILED, \"Payment service unavailable\");\n        }\n    }\n}"
        }
      ],
      "relatedInstructions": ["scal011", "ms004", "api005"]
    },
    {
      "id": "scal011",
      "title": {
        "es": "Implementar retry con backoff exponencial",
        "en": "Implement retry with exponential backoff"
      },
      "description": {
        "es": "Utilizar reintentos inteligentes para mejorar resiliencia sin sobrecargar",
        "en": "Use smart retries to improve resilience without overloading"
      },
      "text": {
        "es": "Implementa un patrón de reintento con backoff exponencial para operaciones que pueden fallar transitoriamente. Aumenta progresivamente el tiempo entre reintentos para reducir la carga en sistemas estresados y mejorar las posibilidades de éxito eventual sin contribuir a problemas de sobrecarga.",
        "en": "Implement a retry pattern with exponential backoff for operations that may fail transiently. Progressively increase the time between retries to reduce load on stressed systems and improve chances of eventual success without contributing to overload problems."
      },
      "importance": "medium",
      "category": "scalability",
      "subcategory": "resilience",
      "tags": ["microservices", "resilience", "best_practices"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Resilience Patterns"
      },
      "compatibility": {
        "frameworks": ["resilience4j", "retry", "polly", "spring-retry"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementación de retry con backoff exponencial en Node.js",
            "en": "Implementing retry with exponential backoff in Node.js"
          },
          "code": "// Retry function with exponential backoff\nasync function retryWithExponentialBackoff(operation, maxRetries = 5, baseDelay = 300) {\n  let retries = 0;\n  \n  while (true) {\n    try {\n      return await operation();\n    } catch (error) {\n      // If we've used all retries, or if error is not retryable, throw\n      if (retries >= maxRetries || !isRetryable(error)) {\n        throw error;\n      }\n      \n      // Calculate delay with exponential backoff and jitter\n      const delay = baseDelay * Math.pow(2, retries) + Math.random() * 100;\n      console.log(`Operation failed. Retrying in ${delay}ms. Retry ${retries + 1}/${maxRetries}`);\n      \n      // Wait before retrying\n      await new Promise(resolve => setTimeout(resolve, delay));\n      retries++;\n    }\n  }\n}\n\n// Determine if an error is retryable\nfunction isRetryable(error) {\n  // Network errors and certain HTTP status codes are often retryable\n  return error.code === 'ECONNRESET' || \n         error.code === 'ETIMEDOUT' || \n         (error.response && (error.response.status === 429 || \n                             error.response.status === 503 || \n                             error.response.status >= 500));\n}\n\n// Example usage\nasync function fetchDataWithRetry() {\n  try {\n    const result = await retryWithExponentialBackoff(\n      () => axios.get('https://api.example.com/data'),\n      3,  // max 3 retries\n      500 // start with 500ms delay\n    );\n    return result.data;\n  } catch (error) {\n    console.error('Failed after multiple retries', error);\n    throw error;\n  }\n}"
        }
      ],
      "relatedInstructions": ["scal010", "ms004", "api005"]
    },
    {
      "id": "scal012",
      "title": {
        "es": "Implementar bulkheads",
        "en": "Implement bulkheads"
      },
      "description": {
        "es": "Aislar componentes críticos para evitar que fallos se propaguen",
        "en": "Isolate critical components to prevent failure propagation"
      },
      "text": {
        "es": "Implementa el patrón de bulkhead para aislar partes de la aplicación, previniendo que los fallos en un componente afecten a otros. Asigna pools de recursos separados (como hilos, conexiones o memoria) a diferentes componentes para que la saturación de uno no impacte en la disponibilidad de los demás.",
        "en": "Implement the bulkhead pattern to isolate parts of your application, preventing failures in one component from affecting others. Allocate separate resource pools (such as threads, connections, or memory) to different components so that saturation of one doesn't impact the availability of others."
      },
      "importance": "medium",
      "category": "scalability",
      "subcategory": "resilience",
      "tags": ["microservices", "resilience", "architecture"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Resilience Patterns"
      },
      "compatibility": {
        "frameworks": ["resilience4j", "hystrix", "istio", "envoy"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementación de bulkheads en Java con ThreadPoolExecutor",
            "en": "Implementing bulkheads in Java with ThreadPoolExecutor"
          },
          "code": "import java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ServiceRegistry {\n\n    // Separate thread pools for different service categories\n    private final ThreadPoolExecutor criticalServicePool;\n    private final ThreadPoolExecutor nonCriticalServicePool;\n    \n    public ServiceRegistry() {\n        // Pool for critical services - small queue to fail fast, more threads\n        criticalServicePool = new ThreadPoolExecutor(\n            10,                       // Core pool size\n            20,                       // Max pool size\n            60, TimeUnit.SECONDS,     // Thread keep-alive time\n            new ArrayBlockingQueue<>(50),  // Bounded queue size\n            new ThreadPoolExecutor.CallerRunsPolicy()  // Backpressure strategy\n        );\n        \n        // Pool for non-critical services - larger queue, fewer threads\n        nonCriticalServicePool = new ThreadPoolExecutor(\n            5,                        // Core pool size\n            10,                       // Max pool size\n            60, TimeUnit.SECONDS,     // Thread keep-alive time\n            new ArrayBlockingQueue<>(100), // Larger queue size\n            new ThreadPoolExecutor.AbortPolicy()  // Different strategy\n        );\n    }\n    \n    // Execute critical service operation\n    public <T> Future<T> executeCriticalOperation(Callable<T> operation) {\n        return criticalServicePool.submit(operation);\n    }\n    \n    // Execute non-critical service operation\n    public <T> Future<T> executeNonCriticalOperation(Callable<T> operation) {\n        return nonCriticalServicePool.submit(operation);\n    }\n    \n    // Shutdown pools gracefully\n    public void shutdown() {\n        criticalServicePool.shutdown();\n        nonCriticalServicePool.shutdown();\n    }\n}"
        }
      ],
      "relatedInstructions": ["scal010", "ms004", "api003"]
    },
    {
      "id": "scal013",
      "title": {
        "es": "Implementar timeout adecuado",
        "en": "Implement proper timeouts"
      },
      "description": {
        "es": "Establecer límites de tiempo para todas las operaciones externas",
        "en": "Set time limits for all external operations"
      },
      "text": {
        "es": "Implementa timeouts explícitos y adecuados para todas las llamadas a servicios externos o recursos remotos. Nunca permitas llamadas sin timeout, ya que podrían bloquear indefinidamente hilos o conexiones valiosas. Ajusta los valores de timeout basándote en datos reales de latencia y contempla diferentes valores según la importancia de cada operación.",
        "en": "Implement explicit and appropriate timeouts for all calls to external services or remote resources. Never allow calls without timeouts, as they could indefinitely block valuable threads or connections. Tune timeout values based on real latency data, and consider different values based on the importance of each operation."
      },
      "importance": "high",
      "category": "scalability",
      "subcategory": "resilience",
      "tags": ["microservices", "resilience", "best_practices"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Resilience Patterns"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementación de timeouts en diferentes lenguajes",
            "en": "Implementing timeouts in different languages"
          },
          "code": "// Java example with HttpClient\nHttpClient client = HttpClient.newBuilder()\n    .connectTimeout(Duration.ofSeconds(5))  // Connection timeout\n    .build();\n\nHttpRequest request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://api.example.com/data\"))\n    .timeout(Duration.ofSeconds(10))  // Request timeout\n    .build();\n\n// Python example with requests\nimport requests\n\ntry:\n    response = requests.get('https://api.example.com/data', \n                         timeout=(3.05, 10))  # (connect timeout, read timeout)\nexcept requests.exceptions.Timeout:\n    # Handle timeout error\n    print(\"The request timed out\")\n\n// JavaScript/Node.js example with axios\nconst axios = require('axios');\n\naxios.get('https://api.example.com/data', {\n  timeout: 5000  // 5 seconds timeout\n}).catch(error => {\n  if (error.code === 'ECONNABORTED') {\n    console.log('Request timed out');\n  }\n});"
        }
      ],
      "relatedInstructions": ["scal010", "scal011", "perf004"]
    },
    {
      "id": "scal014",
      "title": {
        "es": "Implementar backpressure",
        "en": "Implement backpressure"
      },
      "description": {
        "es": "Manejar sobrecarga mediante mecanismos de contrapresión",
        "en": "Handle overload with backpressure mechanisms"
      },
      "text": {
        "es": "Implementa mecanismos de backpressure (contrapresión) para manejar situaciones donde los productores de datos o solicitudes generan más carga de la que los consumidores pueden procesar. Estos mecanismos pueden incluir encolado con límites, throttling, shedding (rechazo de solicitudes) o señalización a productores para reducir su tasa de envío, manteniendo así la estabilidad del sistema.",
        "en": "Implement backpressure mechanisms to handle situations where data producers or request generators create more load than consumers can process. These mechanisms may include bounded queuing, throttling, load shedding (request rejection), or signaling to producers to reduce their sending rate, thus maintaining system stability."
      },
      "importance": "medium",
      "category": "scalability",
      "subcategory": "resilience",
      "tags": ["microservices", "resilience", "stream_processing"],
      "source": {
        "agentType": "general",
        "repository": "system-prompts/devops",
        "context": "Stream Processing Patterns"
      },
      "compatibility": {
        "frameworks": ["rxjava", "akka", "spring-webflux", "reactor"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Backpressure con RxJava",
            "en": "Backpressure with RxJava"
          },
          "code": "import io.reactivex.BackpressureStrategy;\nimport io.reactivex.Flowable;\nimport io.reactivex.schedulers.Schedulers;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\n\n// Create a flowable with backpressure strategy\nFlowable<Integer> flowable = Flowable.create(emitter -> {\n    // This is a fast producer\n    for (int i = 0; i < 1_000_000; i++) {\n        if (emitter.isCancelled()) {\n            return;\n        }\n        emitter.onNext(i);\n        System.out.println(\"Produced: \" + i);\n    }\n    emitter.onComplete();\n}, BackpressureStrategy.BUFFER); // Choose an appropriate backpressure strategy\n\n// Create a custom subscriber (slow consumer)\nflowable\n    .observeOn(Schedulers.io(), false, 16) // Set buffer size for backpressure\n    .subscribe(new Subscriber<Integer>() {\n        private Subscription subscription;\n\n        @Override\n        public void onSubscribe(Subscription s) {\n            this.subscription = s;\n            // Request initial batch size (control the pace)\n            subscription.request(4);\n        }\n\n        @Override\n        public void onNext(Integer item) {\n            System.out.println(\"Consuming: \" + item);\n            \n            try {\n                // Simulate slow processing\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n                subscription.cancel();\n            }\n            \n            // Request the next item (allowing backpressure)\n            subscription.request(1);\n        }\n\n        @Override\n        public void onError(Throwable throwable) {\n            throwable.printStackTrace();\n        }\n\n        @Override\n        public void onComplete() {\n            System.out.println(\"Processing completed\");\n        }\n    });"
        }
      ],
      "relatedInstructions": ["scal009", "scal011", "ms005"]
    }
  ]
}