{
  "instructions": [
    {
      "id": "db_rel_011",
      "title": {
        "es": "Procedimientos almacenados",
        "en": "Stored procedures"
      },
      "description": {
        "es": "Implementar procedimientos almacenados para operaciones complejas o frecuentes",
        "en": "Implement stored procedures for complex or frequent operations"
      },
      "text": {
        "es": "Implementa procedimientos almacenados para encapsular operaciones de base de datos complejas o frecuentes que involucran múltiples pasos, lógica condicional o manejo de transacciones. Los procedimientos almacenados pueden mejorar el rendimiento reduciendo el tráfico de red, proporcionar una capa de abstracción sobre el esquema subyacente, y centralizar la lógica crítica de negocio a nivel de base de datos. Sin embargo, deben usarse juiciosamente, ya que pueden dificultar la portabilidad y el mantenimiento si se usa en exceso.",
        "en": "Implement stored procedures to encapsulate complex or frequent database operations that involve multiple steps, conditional logic, or transaction handling. Stored procedures can improve performance by reducing network traffic, provide an abstraction layer over the underlying schema, and centralize critical business logic at the database level. However, they should be used judiciously as they can make portability and maintenance more challenging if overused."
      },
      "importance": "medium",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["performance", "maintainability", "advanced"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Creando un procedimiento almacenado para procesar un pedido",
            "en": "Creating a stored procedure to process an order"
          },
          "code": "CREATE PROCEDURE process_order(p_customer_id INT, p_product_id INT, p_quantity INT) BEGIN DECLARE v_in_stock INT; START TRANSACTION; SELECT stock INTO v_in_stock FROM products WHERE id = p_product_id; IF v_in_stock >= p_quantity THEN UPDATE products SET stock = stock - p_quantity WHERE id = p_product_id; INSERT INTO orders (customer_id, product_id, quantity) VALUES (p_customer_id, p_product_id, p_quantity); COMMIT; ELSE ROLLBACK; END IF; END;"
        }
      ],
      "relatedInstructions": ["db_rel_010", "db_rel_004"]
    },
    {
      "id": "db_rel_012",
      "title": {
        "es": "Manejo de valores NULL",
        "en": "NULL value handling"
      },
      "description": {
        "es": "Gestionar adecuadamente los valores NULL en el diseño y consultas",
        "en": "Properly handle NULL values in design and queries"
      },
      "text": {
        "es": "Gestiona adecuadamente los valores NULL en el diseño de esquema y consultas SQL. Utiliza restricciones NOT NULL para columnas que siempre deberían tener un valor, pero permite NULLs cuando representan información desconocida o inaplicable de manera semántica. En consultas, ten en cuenta que las comparaciones con NULL requieren operadores específicos (IS NULL, IS NOT NULL) y que NULL en expresiones lógicas sigue reglas de lógica ternaria. Considera valores predeterminados significativos como alternativa a NULL cuando sea apropiado.",
        "en": "Properly handle NULL values in schema design and SQL queries. Use NOT NULL constraints for columns that should always have a value, but allow NULLs when they semantically represent unknown or inapplicable information. In queries, be aware that comparisons with NULL require specific operators (IS NULL, IS NOT NULL) and that NULL in logical expressions follows three-valued logic rules. Consider meaningful default values as an alternative to NULL when appropriate."
      },
      "importance": "medium",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["data_integrity", "query_optimization", "universal"],
      "source": {
        "agentType": "v0",
        "repository": "v0 Prompts and Tools/Prompt.txt",
        "context": "Database Design"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Manejando valores NULL correctamente en consultas SQL",
            "en": "Handling NULL values correctly in SQL queries"
          },
          "code": "SELECT name, COALESCE(phone, 'No Phone') FROM customers WHERE email IS NOT NULL AND (status IS NULL OR status = 'active');"
        }
      ],
      "relatedInstructions": ["db_rel_007", "db_rel_005"]
    },
    {
      "id": "db_rel_013",
      "title": {
        "es": "Auditoria de datos",
        "en": "Data auditing"
      },
      "description": {
        "es": "Implementar mecanismos de auditoría para rastrear cambios en los datos",
        "en": "Implement auditing mechanisms to track data changes"
      },
      "text": {
        "es": "Implementa mecanismos de auditoría para rastrear quién ha modificado los datos, cuándo y qué cambios se hicieron. Esto puede lograrse mediante tablas de historial, triggers de base de datos que registran cambios, o usando características específicas del sistema de gestión de bases de datos como logging de transacciones o registros temporales. La auditoría es crucial para cumplimiento normativo, depuración, seguridad y para mantener una visión histórica de cómo han evolucionado los datos con el tiempo.",
        "en": "Implement auditing mechanisms to track who has modified data, when, and what changes were made. This can be achieved through history tables, database triggers that log changes, or using specific database management system features such as transaction logging or temporal records. Auditing is crucial for regulatory compliance, debugging, security, and maintaining a historical view of how data has evolved over time."
      },
      "importance": "medium",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["data_integrity", "security", "advanced"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementando un sistema de auditoría usando triggers",
            "en": "Implementing an audit system using triggers"
          },
          "code": "CREATE TABLE users_audit (id SERIAL, user_id INT, changed_at TIMESTAMP, operation CHAR(1), old_data JSONB, new_data JSONB); CREATE TRIGGER users_audit_trigger AFTER INSERT OR UPDATE OR DELETE ON users FOR EACH ROW EXECUTE FUNCTION audit_users_changes();"
        }
      ],
      "relatedInstructions": ["db_rel_007", "sec_data_001"]
    },
    {
      "id": "db_rel_014",
      "title": {
        "es": "Gestión de conexiones",
        "en": "Connection management"
      },
      "description": {
        "es": "Implementar gestión eficiente de conexiones a la base de datos",
        "en": "Implement efficient database connection management"
      },
      "text": {
        "es": "Implementa una gestión eficiente de conexiones a la base de datos utilizando pools de conexiones para reducir la sobrecarga de establecer nuevas conexiones para cada operación. Configura los parámetros del pool (tamaño mínimo, máximo, tiempo de vida, etc.) según las características de la carga de trabajo y los recursos disponibles. Asegúrate de que las conexiones se liberan adecuadamente después de su uso, especialmente en caso de errores, para evitar fugas de conexiones.",
        "en": "Implement efficient database connection management using connection pools to reduce the overhead of establishing new connections for each operation. Configure pool parameters (minimum size, maximum size, lifetime, etc.) according to workload characteristics and available resources. Ensure connections are properly released after use, especially in error cases, to prevent connection leaks."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["performance", "resources", "universal"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Configurando un pool de conexiones para una aplicación web",
            "en": "Setting up a connection pool for a web application"
          },
          "code": "// Configuración de pool de conexiones\nconst pool = createPool({\n  host: 'localhost',\n  user: 'app_user',\n  password: 'password',\n  database: 'mydb',\n  min: 5,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000\n});"
        }
      ],
      "relatedInstructions": ["db_rel_008", "db_rel_005"]
    },
    {
      "id": "db_rel_015",
      "title": {
        "es": "Diseño para alta disponibilidad",
        "en": "High availability design"
      },
      "description": {
        "es": "Diseñar bases de datos para alta disponibilidad y tolerancia a fallos",
        "en": "Design databases for high availability and fault tolerance"
      },
      "text": {
        "es": "Diseña bases de datos relacionales con alta disponibilidad y tolerancia a fallos mediante la implementación de técnicas como replicación, clustering, y respaldos automatizados con verificación de integridad. Configura soluciones de failover automático para minimizar tiempos de inactividad en caso de fallos de hardware o software. Define claramente los objetivos de punto de recuperación (RPO) y tiempo de recuperación (RTO) basados en los requisitos de la aplicación y utiliza soluciones apropiadas para cumplir con estos objetivos.",
        "en": "Design relational databases with high availability and fault tolerance by implementing techniques such as replication, clustering, and automated backups with integrity verification. Configure automatic failover solutions to minimize downtime in case of hardware or software failures. Clearly define recovery point objectives (RPO) and recovery time objectives (RTO) based on application requirements and use appropriate solutions to meet these objectives."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["availability", "disaster_recovery", "advanced"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Configurando replicación de bases de datos para alta disponibilidad",
            "en": "Setting up database replication for high availability"
          },
          "code": "-- Configuración de replicación maestro-esclavo en PostgreSQL\nCREATE USER replication_user REPLICATION PASSWORD 'secure_password';\n-- En postgresql.conf (nodo principal): wal_level = replica\n-- En pg_hba.conf (nodo principal): host replication replication_user replica_ip/32 md5"
        }
      ],
      "relatedInstructions": ["db_bkp_001", "db_rel_016"]
    }
  ]
}