{
  "instructions": [
    {
      "id": "db_rel_001",
      "title": {
        "es": "Normalización adecuada",
        "en": "Proper normalization"
      },
      "description": {
        "es": "Aplicar niveles apropiados de normalización a esquemas de bases de datos",
        "en": "Apply appropriate levels of normalization to database schemas"
      },
      "text": {
        "es": "Aplica niveles apropiados de normalización (1NF, 2NF, 3NF, BCNF) a los esquemas de bases de datos relacionales para reducir la redundancia, mejorar la integridad de los datos y facilitar el mantenimiento. Sin embargo, considera desnormalizar estratégicamente en casos específicos donde el rendimiento de lectura es crítico, teniendo en cuenta el equilibrio entre normalización y requisitos de rendimiento.",
        "en": "Apply appropriate levels of normalization (1NF, 2NF, 3NF, BCNF) to relational database schemas to reduce redundancy, improve data integrity, and facilitate maintenance. However, consider strategic denormalization in specific cases where read performance is critical, balancing normalization against performance requirements."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["data_modeling", "schema_design", "universal"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Aplicando normalización a un esquema de base de datos",
            "en": "Applying normalization to a database schema"
          },
          "code": "1NF: eliminar grupos repetitivos + 2NF: eliminar dependencias parciales + 3NF: eliminar dependencias transitivas + BCNF: todas las dependencias determinadas por claves candidatas"
        }
      ],
      "relatedInstructions": ["db_mod_001", "db_rel_002"]
    },
    {
      "id": "db_rel_002",
      "title": {
        "es": "Integridad referencial",
        "en": "Referential integrity"
      },
      "description": {
        "es": "Mantener integridad referencial entre tablas relacionadas",
        "en": "Maintain referential integrity between related tables"
      },
      "text": {
        "es": "Implementa y mantén la integridad referencial entre tablas relacionadas utilizando restricciones de clave foránea con acciones apropiadas en cascada (CASCADE, SET NULL, RESTRICT, etc.). Esto asegura que las relaciones entre tablas permanezcan consistentes y previene datos huérfanos. Las acciones en cascada deben reflejar las reglas de negocio sobre cómo los cambios en una tabla afectan a los datos relacionados.",
        "en": "Implement and maintain referential integrity between related tables using foreign key constraints with appropriate cascade actions (CASCADE, SET NULL, RESTRICT, etc.). This ensures that relationships between tables remain consistent and prevents orphaned data. Cascade actions should reflect business rules about how changes in one table should affect related data."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["data_integrity", "schema_design", "universal"],
      "source": {
        "agentType": "v0",
        "repository": "v0 Prompts and Tools/Prompt.txt",
        "context": "Database Design"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementando integridad referencial con acciones en cascada",
            "en": "Implementing referential integrity with cascade actions"
          },
          "code": "FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE RESTRICT ON UPDATE CASCADE"
        }
      ],
      "relatedInstructions": ["db_rel_001", "db_rel_003"]
    },
    {
      "id": "db_rel_003",
      "title": {
        "es": "Índices apropiados",
        "en": "Appropriate indexing"
      },
      "description": {
        "es": "Crear y mantener índices estratégicos para optimizar el rendimiento",
        "en": "Create and maintain strategic indexes to optimize performance"
      },
      "text": {
        "es": "Crea y mantén índices estratégicos basados en patrones de consulta reales. Los índices deben establecerse en columnas frecuentemente utilizadas en cláusulas WHERE, JOIN y ORDER BY. Considera índices compuestos para consultas que filtran o unen por múltiples columnas en un orden específico. Evita el exceso de índices, ya que pueden degradar el rendimiento de operaciones de escritura y aumentar el uso de almacenamiento.",
        "en": "Create and maintain strategic indexes based on actual query patterns. Indexes should be established on columns frequently used in WHERE clauses, JOINs, and ORDER BY clauses. Consider composite indexes for queries that filter or join on multiple columns in a specific order. Avoid over-indexing, as it can degrade write performance and increase storage usage."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["performance", "query_optimization", "universal"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Creando índices estratégicos para optimizar consultas frecuentes",
            "en": "Creating strategic indexes to optimize frequent queries"
          },
          "code": "CREATE INDEX idx_customers_email ON customers(email); CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);"
        }
      ],
      "relatedInstructions": ["db_qry_001", "db_rel_005"]
    },
    {
      "id": "db_rel_004",
      "title": {
        "es": "Transacciones ACID",
        "en": "ACID transactions"
      },
      "description": {
        "es": "Utilizar transacciones para mantener la integridad y consistencia de los datos",
        "en": "Use transactions to maintain data integrity and consistency"
      },
      "text": {
        "es": "Utiliza transacciones para operaciones que requieren cambios múltiples en la base de datos, asegurando las propiedades ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad). Esto garantiza que una serie de operaciones se completen todas con éxito o ninguna de ellas, manteniendo la base de datos en un estado consistente. Ajusta los niveles de aislamiento según el equilibrio necesario entre consistencia y rendimiento.",
        "en": "Use transactions for operations that require multiple changes to the database, ensuring ACID properties (Atomicity, Consistency, Isolation, Durability). This guarantees that a series of operations either all complete successfully or none of them do, maintaining the database in a consistent state. Adjust isolation levels according to the necessary balance between consistency and performance."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["data_integrity", "concurrency", "universal"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Utilizando transacciones para mantener la consistencia de los datos",
            "en": "Using transactions to maintain data consistency"
          },
          "code": "BEGIN TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; COMMIT TRANSACTION;"
        }
      ],
      "relatedInstructions": ["db_rel_002", "db_rel_008"]
    },
    {
      "id": "db_rel_005",
      "title": {
        "es": "Consultas optimizadas",
        "en": "Optimized queries"
      },
      "description": {
        "es": "Escribir consultas SQL eficientes para optimizar el rendimiento",
        "en": "Write efficient SQL queries to optimize performance"
      },
      "text": {
        "es": "Escribe consultas SQL eficientes seleccionando solo las columnas necesarias, utilizando JOINs adecuados en lugar de subconsultas cuando sea posible, y aplicando cláusulas WHERE efectivas antes de realizar operaciones costosas. Evita funciones en columnas indexadas, usa CTE o tablas temporales para consultas complejas, y considera paginación para conjuntos de resultados grandes. Utiliza herramientas de análisis de consultas para identificar y optimizar consultas lentas.",
        "en": "Write efficient SQL queries by selecting only necessary columns, using appropriate JOINs instead of subqueries when possible, and applying effective WHERE clauses before performing costly operations. Avoid functions on indexed columns, use CTEs or temporary tables for complex queries, and consider pagination for large result sets. Use query analysis tools to identify and optimize slow queries."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "relational_db",
      "tags": ["performance", "query_optimization", "universal"],
      "source": {
        "agentType": "v0",
        "repository": "v0 Prompts and Tools/Prompt.txt",
        "context": "Database Performance"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["sql"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Optimizando una consulta SQL para mejorar el rendimiento",
            "en": "Optimizing an SQL query to improve performance"
          },
          "code": "SELECT u.id, u.name, COUNT(o.id) FROM users u JOIN orders o ON u.id = o.user_id WHERE u.status = 'active' GROUP BY u.id, u.name LIMIT 100 OFFSET 0;"
        }
      ],
      "relatedInstructions": ["db_qry_002", "db_rel_003"]
    }
  ]
}