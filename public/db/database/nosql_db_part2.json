{
  "instructions": [
    {
      "id": "db_nosql_006",
      "title": {
        "es": "Consistencia y transacciones",
        "en": "Consistency and transactions"
      },
      "description": {
        "es": "Manejar adecuadamente la consistencia y las transacciones en entornos distribuidos",
        "en": "Properly handle consistency and transactions in distributed environments"
      },
      "text": {
        "es": "Gestiona adecuadamente la consistencia de datos y las transacciones en bases de datos NoSQL, reconociendo que muchas soluciones NoSQL favorecen la disponibilidad y tolerancia a particiones sobre la consistencia estricta (teorema CAP). Utiliza patrones de diseño como actualizaciones idempotentes, modelos de consistencia eventual, y compensación para mantener la integridad de los datos. Para casos que requieren garantías transaccionales, considera bases de datos NoSQL que ofrecen transacciones ACID a nivel de documento o implementa patrones como SAGA para coordinar operaciones distribuidas.",
        "en": "Properly manage data consistency and transactions in NoSQL databases, recognizing that many NoSQL solutions favor availability and partition tolerance over strict consistency (CAP theorem). Use design patterns such as idempotent updates, eventual consistency models, and compensation to maintain data integrity. For cases requiring transactional guarantees, consider NoSQL databases that offer document-level ACID transactions or implement patterns like SAGA to coordinate distributed operations."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "nosql_db",
      "tags": ["data_integrity", "distributed_systems", "advanced"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Implementando transacciones en MongoDB",
            "en": "Implementing transactions in MongoDB"
          },
          "code": "// Usando transacciones en MongoDB\nconst session = client.startSession();\nsession.startTransaction();\ntry {\n  await collection1.updateOne({ _id: id1 }, { $set: { status: 'processing' } }, { session });\n  await collection2.insertOne({ orderId: id1, ... }, { session });\n  await session.commitTransaction();\n} catch (error) {\n  await session.abortTransaction();\n  throw error;\n} finally {\n  session.endSession();\n}"
        }
      ],
      "relatedInstructions": ["db_nosql_003", "db_rel_004"]
    },
    {
      "id": "db_nosql_007",
      "title": {
        "es": "Estrategias de almacenamiento",
        "en": "Storage strategies"
      },
      "description": {
        "es": "Seleccionar e implementar estrategias de almacenamiento apropiadas",
        "en": "Select and implement appropriate storage strategies"
      },
      "text": {
        "es": "Selecciona e implementa estrategias de almacenamiento apropiadas para bases de datos NoSQL considerando los patrones de acceso, volumen de datos, frecuencia de escrituras/lecturas, y requisitos de rendimiento. Evalúa opciones como almacenamiento en memoria para datos de alta frecuencia de acceso, almacenamiento en disco para datos persistentes, y estrategias híbridas para balancear rendimiento y durabilidad. Considera también políticas de expiración, compresión, y tiering para optimizar el uso de recursos y costos de almacenamiento a largo plazo.",
        "en": "Select and implement appropriate storage strategies for NoSQL databases considering access patterns, data volume, read/write frequencies, and performance requirements. Evaluate options such as in-memory storage for high-frequency access data, disk storage for persistent data, and hybrid strategies to balance performance and durability. Also consider expiration policies, compression, and tiering to optimize resource usage and long-term storage costs."
      },
      "importance": "medium",
      "category": "database",
      "subcategory": "nosql_db",
      "tags": ["performance", "cost_optimization", "advanced"],
      "source": {
        "agentType": "v0",
        "repository": "v0 Prompts and Tools/Prompt.txt",
        "context": "Database Design"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Configurando políticas de almacenamiento en Redis",
            "en": "Configuring storage policies in Redis"
          },
          "code": "// Configurar política de expiración para datos de sesión\nREDIS-CLI> SET session:12345 '{...}' EX 3600\n\n// Configurar política de evicción LRU para limitar uso de memoria\nredis.conf: maxmemory 2gb\nredis.conf: maxmemory-policy allkeys-lru"
        }
      ],
      "relatedInstructions": ["db_nosql_001", "db_rel_006"]
    },
    {
      "id": "db_nosql_008",
      "title": {
        "es": "Patrones de consulta específicos",
        "en": "Specific query patterns"
      },
      "description": {
        "es": "Implementar patrones de consulta y acceso específicos para cada tipo de base de datos NoSQL",
        "en": "Implement specific query and access patterns for each NoSQL database type"
      },
      "text": {
        "es": "Implementa patrones de consulta y acceso específicos adaptados al tipo de base de datos NoSQL que estés utilizando. Para bases de datos de documentos, utiliza consultas anidadas e índices compuestos; para bases de datos clave-valor, diseña claves compuestas inteligentes; para bases de datos columnares, optimiza para familias de columnas y consultas de rango; y para bases de datos de grafos, utiliza recorridos y algoritmos de grafos. Comprende las capacidades y limitaciones de consulta de cada tecnología para escribir operaciones eficientes y escalables.",
        "en": "Implement specific query and access patterns tailored to the NoSQL database type you're using. For document databases, utilize nested queries and compound indexes; for key-value databases, design intelligent composite keys; for columnar databases, optimize for column families and range queries; and for graph databases, leverage traversals and graph algorithms. Understand the querying capabilities and limitations of each technology to write efficient and scalable operations."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "nosql_db",
      "tags": ["query_optimization", "database_specific", "universal"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Patrones de consulta para diferentes bases de datos NoSQL",
            "en": "Query patterns for different NoSQL databases"
          },
          "code": "// MongoDB: Consulta anidada con proyección\ndb.users.find({ \"address.city\": \"New York\" }, { name: 1, email: 1 })\n\n// Redis: Clave compuesta para rangos\nREDIS-CLI> ZADD user:12345:posts 1621728000 post1 1623024000 post2\nREDIS-CLI> ZRANGEBYSCORE user:12345:posts 1619827200 1625097600\n\n// Cassandra: Consulta optimizada para modelo columnar\nCQL> SELECT * FROM user_events WHERE user_id = 12345 AND event_date > '2023-01-01';\n\n// Neo4j: Recorrido de grafo\nCYPHER> MATCH (user:User {name: 'John'})-[:FOLLOWS*1..2]->(followed) RETURN followed.name;"
        }
      ],
      "relatedInstructions": ["db_nosql_004", "db_qry_001"]
    },
    {
      "id": "db_nosql_009",
      "title": {
        "es": "Manejo de datos polimórficos",
        "en": "Polymorphic data handling"
      },
      "description": {
        "es": "Gestionar eficientemente estructuras de datos variables o polimórficas",
        "en": "Efficiently manage variable or polymorphic data structures"
      },
      "text": {
        "es": "Gestiona eficientemente estructuras de datos variables o polimórficas en bases de datos NoSQL, aprovechando la flexibilidad inherente de estos sistemas. Implementa patrones como discriminadores de tipo, herencia con composición, o esquemas híbridos para manejar entidades con atributos variables. Establece convenciones claras para identificar tipos de documentos y validar estructuras. Equilibra la flexibilidad con la consistencia implementando validación de esquemas cuando sea apropiado, manteniendo la coherencia de los datos sin perder las ventajas de la flexibilidad del esquema.",
        "en": "Efficiently manage variable or polymorphic data structures in NoSQL databases, leveraging the inherent flexibility of these systems. Implement patterns such as type discriminators, inheritance with composition, or hybrid schemas to handle entities with varying attributes. Establish clear conventions for identifying document types and validating structures. Balance flexibility with consistency by implementing schema validation where appropriate, maintaining data coherence without losing the advantages of schema flexibility."
      },
      "importance": "medium",
      "category": "database",
      "subcategory": "nosql_db",
      "tags": ["schema_design", "data_modeling", "advanced"],
      "source": {
        "agentType": "v0",
        "repository": "v0 Prompts and Tools/Prompt.txt",
        "context": "Database Design"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Manejando datos polimórficos en MongoDB",
            "en": "Handling polymorphic data in MongoDB"
          },
          "code": "// Usando discriminador de tipo para contenido mixto\n{\n  \"_id\": \"item1\",\n  \"type\": \"article\",\n  \"title\": \"NoSQL Best Practices\",\n  \"content\": \"...\",\n  \"author\": \"Jane Doe\"\n}\n\n{\n  \"_id\": \"item2\",\n  \"type\": \"video\",\n  \"title\": \"NoSQL Tutorial\",\n  \"duration\": 3600,\n  \"resolution\": \"1080p\",\n  \"creator\": \"John Smith\"\n}"
        }
      ],
      "relatedInstructions": ["db_nosql_003", "db_mod_003"]
    },
    {
      "id": "db_nosql_010",
      "title": {
        "es": "Manejo de relaciones",
        "en": "Relationship handling"
      },
      "description": {
        "es": "Implementar estrategias para manejar relaciones entre entidades",
        "en": "Implement strategies for handling relationships between entities"
      },
      "text": {
        "es": "Implementa estrategias apropiadas para manejar relaciones entre entidades en bases de datos NoSQL, basadas en patrones de acceso y características específicas de la base de datos. Utiliza embebido para relaciones uno-a-pocos con acceso conjunto frecuente, referencia para relaciones uno-a-muchos o muchos-a-muchos donde el embebido causaría documentos excesivamente grandes, y denormalización controlada para optimizar patrones de lectura comunes. Para relaciones complejas, considera usar múltiples representaciones de la misma relación optimizadas para diferentes patrones de consulta.",
        "en": "Implement appropriate strategies for handling relationships between entities in NoSQL databases, based on access patterns and database-specific characteristics. Use embedding for one-to-few relationships with frequent joint access, referencing for one-to-many or many-to-many relationships where embedding would cause excessively large documents, and controlled denormalization to optimize for common read patterns. For complex relationships, consider using multiple representations of the same relationship optimized for different query patterns."
      },
      "importance": "high",
      "category": "database",
      "subcategory": "nosql_db",
      "tags": ["data_modeling", "schema_design", "universal"],
      "source": {
        "agentType": "devin",
        "repository": "Devin AI/devin.txt",
        "context": "Database Best Practices"
      },
      "compatibility": {
        "frameworks": ["all"],
        "languages": ["all"],
        "environments": ["all"]
      },
      "examples": [
        {
          "context": {
            "es": "Estrategias para manejar relaciones en MongoDB",
            "en": "Strategies for handling relationships in MongoDB"
          },
          "code": "// Embebido: Relación uno-a-pocos (usuario y direcciones)\n{\n  \"_id\": \"user123\",\n  \"name\": \"John Doe\",\n  \"addresses\": [\n    { \"type\": \"home\", \"street\": \"123 Main St\", \"city\": \"Springfield\" },\n    { \"type\": \"work\", \"street\": \"456 Market St\", \"city\": \"Springfield\" }\n  ]\n}\n\n// Referencia: Relación uno-a-muchos (usuario y pedidos)\n// Usuario: { \"_id\": \"user123\", \"name\": \"John Doe\" }\n// Pedidos: [{ \"_id\": \"order1\", \"user_id\": \"user123\", ... }]"
        }
      ],
      "relatedInstructions": ["db_nosql_002", "db_rel_001"]
    }
  ]
}